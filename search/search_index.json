{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p><code>aurora-unicycler</code> provides a universal cycling protocol Python class.</p> <p>Cycling protocols can be defined in Python or with JSON, and exported to different formats:   - Biologic .mps   - Neware .xml   - tomato 0.2.3 .json   - PyBaMM string list   - BattINFO .jsonld</p> <p>This is particularly useful for high-throughput battery experiments, as protocols can be programmatically defined, and sample IDs and capacities can be attached at the last second.</p> <p>We try to make the protocol clear and unambiguous, and abstract away idiosyncrasies of the backend of different cycling protocols.</p> <p>The main class in <code>aurora-unicycler</code> is the <code>Protocol</code>, which contains the <code>method</code> - a list of steps to carry out, as well as safety and recording parameters and limited sample details.</p> <p>Under-the-hood, these are <code>pydantic</code> models, which allows for powerful validation and type checking.</p>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>This software was developed at the Laboratory of Materials for Energy Conversion at Empa, the Swiss Federal Laboratories for Materials Science and Technology, and supported by funding from the IntelLiGent project from the European Union\u2019s research and innovation program under grant agreement No. 101069765, and from the Swiss State Secretariat for Education, Research, and Innovation (SERI) under contract No. 22.001422.</p>"},{"location":"api/","title":"API Reference","text":"<p>A universal cycling protocol which can be converted to different formats.</p> <p>Create a Protocol object directly, or create from a dict or JSON file.</p> <p>Convert to different formats e.g. <code>.to_neware_xml()</code> or <code>to_biologic_mps()</code>.</p>"},{"location":"api/#aurora_unicycler.ConstantCurrent","title":"<code>ConstantCurrent</code>","text":"<p>               Bases: <code>Step</code></p> <p>Constant current step.</p> <p>At least one of <code>rate_C</code> or <code>current_mA</code> must be set. If <code>rate_C</code> is used, a sample capacity must be set in the Protocol, and it will take priority over <code>current_mA</code>.</p> <p>The termination ('until') conditions are OR conditions, the step will end when any one of these is met.</p> <p>Attributes:</p> Name Type Description <code>rate_C</code> <code>float | None</code> <p>(optional) The current applied in C-rate units (i.e. mA per mAh).</p> <code>current_mA</code> <code>float | None</code> <p>(optional) The current applied in mA.</p> <code>until_time_s</code> <code>float | None</code> <p>Duration of step in seconds.</p> <code>until_voltage_V</code> <code>float | None</code> <p>End step when this voltage in V is reached.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class ConstantCurrent(Step):\n    \"\"\"Constant current step.\n\n    At least one of `rate_C` or `current_mA` must be set. If `rate_C` is used, a\n    sample capacity must be set in the Protocol, and it will take priority over\n    `current_mA`.\n\n    The termination ('until') conditions are OR conditions, the step will end\n    when any one of these is met.\n\n    Attributes:\n        rate_C: (optional) The current applied in C-rate units (i.e. mA per mAh).\n        current_mA: (optional) The current applied in mA.\n        until_time_s: Duration of step in seconds.\n        until_voltage_V: End step when this voltage in V is reached.\n\n    \"\"\"\n\n    step: Literal[\"constant_current\"] = Field(default=\"constant_current\", frozen=True)\n    rate_C: float | None = None\n    current_mA: float | None = None\n    until_time_s: float | None = None\n    until_voltage_V: float | None = None\n\n    @field_validator(\"rate_C\", mode=\"before\")\n    @classmethod\n    def _parse_c_rate(cls, v: float | str) -&gt; float | None:\n        \"\"\"C-rate can be a string e.g. \"C/2\".\"\"\"\n        return _coerce_c_rate(v)\n\n    @field_validator(\"current_mA\", \"until_time_s\", \"until_voltage_V\", mode=\"before\")\n    @classmethod\n    def _allow_empty_string(cls, v: float | str) -&gt; float | None:\n        \"\"\"Empty string is interpreted as None.\"\"\"\n        return _empty_string_is_none(v)\n\n    @model_validator(mode=\"after\")\n    def _ensure_rate_or_current(self) -&gt; Self:\n        \"\"\"Ensure at least one of rate_C or current_mA is set.\"\"\"\n        has_rate_C = self.rate_C is not None and self.rate_C != 0\n        has_current_mA = self.current_mA is not None and self.current_mA != 0\n        if not (has_rate_C or has_current_mA):\n            msg = \"Either rate_C or current_mA must be set and non-zero.\"\n            raise ValueError(msg)\n        return self\n\n    @model_validator(mode=\"after\")\n    def _ensure_stop_condition(self) -&gt; Self:\n        \"\"\"Ensure at least one stop condition is set.\"\"\"\n        has_time_s = self.until_time_s is not None and self.until_time_s != 0\n        has_voltage_V = self.until_voltage_V is not None and self.until_voltage_V != 0\n        if not (has_time_s or has_voltage_V):\n            msg = \"Either until_time_s or until_voltage_V must be set and non-zero.\"\n            raise ValueError(msg)\n        return self\n</code></pre>"},{"location":"api/#aurora_unicycler.ConstantVoltage","title":"<code>ConstantVoltage</code>","text":"<p>               Bases: <code>Step</code></p> <p>Constant voltage step.</p> <p>The termination ('until') conditions are OR conditions, the step will end when any one of these is met. If both <code>until_rate_C</code> and <code>until_current_mA</code> are set, C-rate will take priority.</p> <p>Note that in most cyclers, a voltage is not applied directly, instead the current is adjusted to achieve a certain voltage.</p> <p>Attributes:</p> Name Type Description <code>voltage_V</code> <code>float</code> <p>The voltage applied in V.</p> <code>until_time_s</code> <code>float | None</code> <p>Duration of step in seconds.</p> <code>until_rate_C</code> <code>float | None</code> <p>End step when this C-rate (i.e. mA per mAh) is reached.</p> <code>until_current_mA</code> <code>float | None</code> <p>End step when this current in mA is reached.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class ConstantVoltage(Step):\n    \"\"\"Constant voltage step.\n\n    The termination ('until') conditions are OR conditions, the step will end\n    when any one of these is met. If both `until_rate_C` and `until_current_mA`\n    are set, C-rate will take priority.\n\n    Note that in most cyclers, a voltage is not applied directly, instead the\n    current is adjusted to achieve a certain voltage.\n\n    Attributes:\n        voltage_V: The voltage applied in V.\n        until_time_s: Duration of step in seconds.\n        until_rate_C: End step when this C-rate (i.e. mA per mAh) is reached.\n        until_current_mA: End step when this current in mA is reached.\n\n    \"\"\"\n\n    step: Literal[\"constant_voltage\"] = Field(default=\"constant_voltage\", frozen=True)\n    voltage_V: float\n    until_time_s: float | None = None\n    until_rate_C: float | None = None\n    until_current_mA: float | None = None\n\n    @field_validator(\"until_rate_C\", mode=\"before\")\n    @classmethod\n    def _parse_c_rate(cls, v: float | str) -&gt; float | None:\n        \"\"\"C-rate can be a string e.g. \"C/2\".\"\"\"\n        return _coerce_c_rate(v)\n\n    @field_validator(\"voltage_V\", \"until_time_s\", \"until_current_mA\", mode=\"before\")\n    @classmethod\n    def _allow_empty_string(cls, v: float | str) -&gt; float | None:\n        \"\"\"Empty string is interpreted as None.\"\"\"\n        return _empty_string_is_none(v)\n\n    @model_validator(mode=\"after\")\n    def _check_stop_condition(self) -&gt; Self:\n        \"\"\"Ensure at least one of until_rate_C or until_current_mA is set.\"\"\"\n        has_time_s = self.until_time_s is not None and self.until_time_s != 0\n        has_rate_C = self.until_rate_C is not None and self.until_rate_C != 0\n        has_current_mA = self.until_current_mA is not None and self.until_current_mA != 0\n        if not (has_time_s or has_rate_C or has_current_mA):\n            msg = \"Either until_time_s, until_rate_C, or until_current_mA must be set and non-zero.\"\n            raise ValueError(msg)\n        return self\n</code></pre>"},{"location":"api/#aurora_unicycler.ImpedanceSpectroscopy","title":"<code>ImpedanceSpectroscopy</code>","text":"<p>               Bases: <code>Step</code></p> <p>Electrochemical Impedance Spectroscopy (EIS) step.</p> <p>Only one of <code>amplitude_V</code> (PEIS) or <code>amplitude_mA</code> (GEIS) can be set.</p> <p>Attributes:</p> Name Type Description <code>amplitude_V</code> <code>float | None</code> <p>(optional) Oscillation amplitude in V.</p> <code>amplitude_mA</code> <code>float | None</code> <p>(optional) Oscillation amplitude in mA.</p> <code>start_frequency_Hz</code> <code>float</code> <p>Beginning frequency in Hz.</p> <code>end_frequency_Hz</code> <code>float</code> <p>End frequency in Hz.</p> <code>points_per_decade</code> <code>int</code> <p>How many points to measure per decade, i.e. power of 10.</p> <code>measures_per_point</code> <code>int</code> <p>How many measurements to average per point.</p> <code>drift_correction</code> <code>bool | None</code> <p>Corrects for drift in the system - requires twice as many measurements. Compensates measured current/voltage at frequency <code>f_m</code> with points<code>f_m-1</code> and <code>f_m+1</code> using the formula for PEIS <code>\u2206I(f_m) = I(f_m) + (I(f_m+1) - I(f_m-1))/2</code>, (and similar for V in GEIS). Operates on both real and imaginary parts.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class ImpedanceSpectroscopy(Step):\n    \"\"\"Electrochemical Impedance Spectroscopy (EIS) step.\n\n    Only one of `amplitude_V` (PEIS) or `amplitude_mA` (GEIS) can be set.\n\n    Attributes:\n        amplitude_V: (optional) Oscillation amplitude in V.\n        amplitude_mA: (optional) Oscillation amplitude in mA.\n        start_frequency_Hz: Beginning frequency in Hz.\n        end_frequency_Hz: End frequency in Hz.\n        points_per_decade: How many points to measure per decade, i.e. power of 10.\n        measures_per_point: How many measurements to average per point.\n        drift_correction: Corrects for drift in the system - requires twice as\n            many measurements. Compensates measured current/voltage at frequency\n            `f_m` with points`f_m-1` and `f_m+1` using the formula for PEIS\n            `\u2206I(f_m) = I(f_m) + (I(f_m+1) - I(f_m-1))/2`, (and similar for V in\n            GEIS). Operates on both real and imaginary parts.\n\n    \"\"\"\n\n    step: Literal[\"impedance_spectroscopy\"] = Field(default=\"impedance_spectroscopy\", frozen=True)\n    amplitude_V: float | None = None\n    amplitude_mA: float | None = None\n    start_frequency_Hz: float = Field(ge=1e-5, le=1e5, description=\"Start frequency in Hz\")\n    end_frequency_Hz: float = Field(ge=1e-5, le=1e5, description=\"End frequency in Hz\")\n    points_per_decade: int = Field(gt=0, default=10)\n    measures_per_point: int = Field(gt=0, default=1)\n    drift_correction: bool | None = Field(default=False, description=\"Apply drift correction\")\n    model_config = ConfigDict(extra=\"forbid\")\n\n    @field_validator(\"amplitude_V\", \"amplitude_mA\", mode=\"before\")\n    @classmethod\n    def _allow_empty_string(cls, v: float | str) -&gt; float | None:\n        \"\"\"Empty string is interpreted as None.\"\"\"\n        return _empty_string_is_none(v)\n\n    @model_validator(mode=\"after\")\n    def _validate_amplitude(self) -&gt; Self:\n        \"\"\"Cannot set both amplitude_V and amplitude_mA.\"\"\"\n        if self.amplitude_V is not None and self.amplitude_mA is not None:\n            msg = \"Cannot set both amplitude_V and amplitude_mA.\"\n            raise ValueError(msg)\n        if self.amplitude_V is None and self.amplitude_mA is None:\n            msg = \"Either amplitude_V or amplitude_mA must be set.\"\n            raise ValueError(msg)\n        return self\n</code></pre>"},{"location":"api/#aurora_unicycler.Loop","title":"<code>Loop</code>","text":"<p>               Bases: <code>Step</code></p> <p>Loop step.</p> <p>Supports both looping to a tag or the step number (1-indexed). It is recommened to use tags to avoid potential errors with indexing or when adding/removing steps.</p> <p>Internally, tags are converted to indexes with the correct indexing when sending to cyclers.</p> <p>Attributes:</p> Name Type Description <code>loop_to</code> <code>Annotated[int | str, Field()]</code> <p>The tag or step number (1-indexed) to loop back to.</p> <code>cycle_count</code> <code>int</code> <p>How many times to loop. This is the TOTAL number of cycles. Different cyclers define this differently. Here, a cycle_count of 3 means 3 cycles in total will be performed.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class Loop(Step):\n    \"\"\"Loop step.\n\n    Supports both looping to a tag or the step number (1-indexed). It is\n    recommened to use tags to avoid potential errors with indexing or when\n    adding/removing steps.\n\n    Internally, tags are converted to indexes with the correct indexing when\n    sending to cyclers.\n\n    Attributes:\n        loop_to: The tag or step number (1-indexed) to loop back to.\n        cycle_count: How many times to loop. This is the TOTAL number of cycles.\n            Different cyclers define this differently. Here, a cycle_count of 3\n            means 3 cycles in total will be performed.\n\n    \"\"\"\n\n    step: Literal[\"loop\"] = Field(default=\"loop\", frozen=True)\n    loop_to: Annotated[int | str, Field()] = Field(default=1)\n    cycle_count: int = Field(gt=0)\n    model_config = ConfigDict(extra=\"forbid\")\n\n    @field_validator(\"loop_to\")\n    @classmethod\n    def _validate_loop_to(cls, v: int | str) -&gt; int | str:\n        \"\"\"Ensure loop_to is a positive integer or a string.\"\"\"\n        if isinstance(v, int) and v &lt;= 0:\n            msg = \"Start step must be positive integer or a string\"\n            raise ValueError(msg)\n        if isinstance(v, str) and v.strip() == \"\":\n            msg = \"Start step cannot be empty\"\n            raise ValueError(msg)\n        return v\n</code></pre>"},{"location":"api/#aurora_unicycler.OpenCircuitVoltage","title":"<code>OpenCircuitVoltage</code>","text":"<p>               Bases: <code>Step</code></p> <p>Open circuit voltage step.</p> <p>Attributes:</p> Name Type Description <code>until_time_s</code> <code>float</code> <p>Duration of step in seconds.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class OpenCircuitVoltage(Step):\n    \"\"\"Open circuit voltage step.\n\n    Attributes:\n        until_time_s: Duration of step in seconds.\n\n    \"\"\"\n\n    step: Literal[\"open_circuit_voltage\"] = Field(default=\"open_circuit_voltage\", frozen=True)\n    until_time_s: float = Field(gt=0)\n\n    @field_validator(\"until_time_s\", mode=\"before\")\n    @classmethod\n    def _allow_empty_string(cls, v: float | str) -&gt; float | None:\n        \"\"\"Empty string is interpreted as None.\"\"\"\n        return _empty_string_is_none(v)\n</code></pre>"},{"location":"api/#aurora_unicycler.Protocol","title":"<code>Protocol</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Protocol model which can be converted to various formats.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class Protocol(BaseModel):\n    \"\"\"Protocol model which can be converted to various formats.\"\"\"\n\n    unicycler: UnicyclerParams = Field(default_factory=UnicyclerParams)\n    sample: SampleParams = Field(default_factory=SampleParams)\n    record: RecordParams\n    safety: SafetyParams = Field(default_factory=SafetyParams)\n    method: Sequence[AnyTechnique] = Field(min_length=1)  # Ensure at least one step\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    # Only checked when outputting\n    def _validate_capacity_c_rates(self) -&gt; None:\n        \"\"\"Ensure if using C-rate steps, a capacity is set.\"\"\"\n        if not self.sample.capacity_mAh and any(\n            getattr(s, \"rate_C\", None) or getattr(s, \"until_rate_C\", None) for s in self.method\n        ):\n            msg = \"Sample capacity must be set if using C-rate steps.\"\n            raise ValueError(msg)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _check_no_blank_steps(cls, values: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Check if any 'blank' steps are in the method before trying to parse them.\"\"\"\n        steps = values.get(\"method\", [])\n        for i, step in enumerate(steps):\n            if (isinstance(step, Step) and not hasattr(step, \"step\")) or (\n                isinstance(step, dict) and (\"step\" not in step or not step[\"step\"])\n            ):\n                msg = f\"Step at index {i} is incomplete, needs a 'step' type.\"\n                raise ValueError(msg)\n        return values\n\n    @model_validator(mode=\"after\")\n    def _validate_loops_and_tags(self) -&gt; Self:\n        \"\"\"Ensure that if a loop uses a string, it is a valid tag.\"\"\"\n        loop_tags = {\n            i: step.loop_to\n            for i, step in enumerate(self.method)\n            if isinstance(step, Loop) and isinstance(step.loop_to, str)\n        }\n        loop_idx = {\n            i: step.loop_to\n            for i, step in enumerate(self.method)\n            if isinstance(step, Loop) and isinstance(step.loop_to, int)\n        }\n        tags = {i: step.tag for i, step in enumerate(self.method) if isinstance(step, Tag)}\n\n        # Cannot have duplicate tags\n        tag_list = list(tags.values())\n        if len(tag_list) != len(set(tag_list)):\n            duplicate_tags = {\"'\" + tag + \"'\" for tag in tag_list if tag_list.count(tag) &gt; 1}\n            msg = \"Duplicate tags: \" + \", \".join(duplicate_tags)\n            raise ValueError(msg)\n\n        tags_rev = {v: k for k, v in tags.items()}  # to map from tag to index\n\n        # indexed loops cannot go on itself or forwards\n        for i, loop_start in loop_idx.items():\n            if loop_start &gt;= i:\n                msg = f\"Loop start index {loop_start} cannot be on or after the loop index {i}.\"\n                raise ValueError(msg)\n\n        # Loops cannot go forwards to tags, or back one index to a tag\n        for i, loop_tag in loop_tags.items():\n            if loop_tag not in tags_rev:\n                msg = f\"Tag '{loop_tag}' is missing.\"\n                raise ValueError(msg)\n            # loop_tag is in tags, ensure i is larger than the tag index\n            tag_i = tags_rev[loop_tag]\n            if i &lt;= tag_i:\n                msg = f\"Loops must go backwards, '{loop_tag}' goes forwards ({i}-&gt;{tag_i}).\"\n                raise ValueError(msg)\n            if i == tag_i + 1:\n                msg = f\"Loop '{loop_tag}' cannot start immediately after its tag.\"\n                raise ValueError(msg)\n        return self\n\n    def _tag_to_indices(self) -&gt; None:\n        \"\"\"Convert tag steps into indices to be processed later.\"\"\"\n        # In a protocol the steps are 1-indexed and tags should be ignored\n        # The loop function should point to the index of the step AFTER the corresponding tag\n        indices = [0] * len(self.method)\n        tags = {}\n        methods_to_remove = []\n        j = 0\n        for i, step in enumerate(self.method):\n            if isinstance(step, Tag):\n                indices[i] = j + 1\n                tags[step.tag] = j + 1\n                # drop this step from the list\n                methods_to_remove.append(i)\n            elif isinstance(step, Step):\n                j += 1\n                indices[i] = j\n                if isinstance(step, Loop):\n                    if isinstance(step.loop_to, str):\n                        # If the start step is a string, it should be a tag, go to the tag index\n                        try:\n                            step.loop_to = tags[step.loop_to]\n                        except KeyError as e:\n                            msg = (\n                                f\"Loop step with tag {step.loop_to} \"\n                                \"does not have a corresponding tag step.\"\n                            )\n                            raise ValueError(msg) from e\n                    else:\n                        # If the start step is an int, it should be the NEW index of the step\n                        step.loop_to = indices[step.loop_to - 1]\n            else:\n                methods_to_remove.append(i)\n        # Remove tags and other invalid steps\n        self.method = [step for i, step in enumerate(self.method) if i not in methods_to_remove]\n\n    def _check_for_intersecting_loops(self) -&gt; None:\n        \"\"\"Check if a method has intersecting loops. Cannot contain Tags.\"\"\"\n        loops = []\n        for i, step in enumerate(self.method):\n            if isinstance(step, Loop):\n                loops.append((int(step.loop_to), i + 1))\n        loops.sort()\n\n        for i in range(len(loops)):\n            for j in range(i + 1, len(loops)):\n                i_start, i_end = loops[i]\n                j_start, j_end = loops[j]\n\n                # If loop j starts after loop i ends, stop checking i\n                if j_start &gt; i_end:\n                    break\n\n                # Otherwise check if they intersect, completely nested is okay\n                if (i_start &lt; j_start and i_end &lt; j_end) or (i_start &gt; j_start and i_end &gt; j_end):\n                    msg = \"Protocol has intersecting loops.\"\n                    raise ValueError(msg)\n\n    def to_neware_xml(\n        self,\n        save_path: Path | str | None = None,\n        sample_name: str | None = None,\n        capacity_mAh: float | None = None,\n    ) -&gt; str:\n        \"\"\"Convert the protocol to Neware XML format.\n\n        Args:\n            save_path: (optional) File path of where to save the xml file.\n            sample_name: (optional) Override the protocol sample name. A sample\n                name must be provided in this function. It is stored as the\n                'barcode' of the Neware protocol.\n            capacity_mAh: (optional) Override the protocol sample capacity.\n\n        Returns:\n            xml string representation of the protocol.\n\n        \"\"\"\n        # Create and operate on a copy of the original object\n        protocol = self.model_copy()\n\n        # Allow overwriting name and capacity\n        if sample_name:\n            protocol.sample.name = sample_name\n        if capacity_mAh:\n            protocol.sample.capacity_mAh = capacity_mAh\n\n        # Make sure sample name is set\n        if not protocol.sample.name or protocol.sample.name == \"$NAME\":\n            msg = (\n                \"If using blank sample name or $NAME placeholder, \"\n                \"a sample name must be provided in this function.\"\n            )\n            raise ValueError(msg)\n\n        # Make sure capacity is set if using C-rate steps\n        protocol._validate_capacity_c_rates()\n\n        # Remove tags and convert to indices\n        protocol._tag_to_indices()\n        protocol._check_for_intersecting_loops()\n\n        # Create XML structure\n        root = ET.Element(\"root\")\n        config = ET.SubElement(\n            root,\n            \"config\",\n            type=\"Step File\",\n            version=\"17\",\n            client_version=\"BTS Client 8.0.0.478(2024.06.24)(R3)\",\n            date=datetime.now().strftime(\"%Y%m%d%H%M%S\"),\n            Guid=str(uuid.uuid4()),\n        )\n        head_info = ET.SubElement(config, \"Head_Info\")\n        ET.SubElement(head_info, \"Operate\", Value=\"66\")\n        ET.SubElement(head_info, \"Scale\", Value=\"1\")\n        ET.SubElement(head_info, \"Start_Step\", Value=\"1\", Hide_Ctrl_Step=\"0\")\n        ET.SubElement(head_info, \"Creator\", Value=\"aurora-unicycler\")\n        ET.SubElement(head_info, \"Remark\", Value=protocol.sample.name)\n        # 103, non C-rate mode, seems to give more precise values vs 105\n        ET.SubElement(head_info, \"RateType\", Value=\"103\")\n        if protocol.sample.capacity_mAh:\n            ET.SubElement(head_info, \"MultCap\", Value=f\"{protocol.sample.capacity_mAh * 3600:f}\")\n\n        whole_prt = ET.SubElement(config, \"Whole_Prt\")\n        protect = ET.SubElement(whole_prt, \"Protect\")\n        main_protect = ET.SubElement(protect, \"Main\")\n        volt = ET.SubElement(main_protect, \"Volt\")\n        if protocol.safety.max_voltage_V:\n            ET.SubElement(volt, \"Upper\", Value=f\"{protocol.safety.max_voltage_V * 10000:f}\")\n        if protocol.safety.min_voltage_V:\n            ET.SubElement(volt, \"Lower\", Value=f\"{protocol.safety.min_voltage_V * 10000:f}\")\n        curr = ET.SubElement(main_protect, \"Curr\")\n        if protocol.safety.max_current_mA:\n            ET.SubElement(curr, \"Upper\", Value=f\"{protocol.safety.max_current_mA:f}\")\n        if protocol.safety.min_current_mA:\n            ET.SubElement(curr, \"Lower\", Value=f\"{protocol.safety.min_current_mA:f}\")\n        if protocol.safety.delay_s:\n            ET.SubElement(main_protect, \"Delay_Time\", Value=f\"{protocol.safety.delay_s * 1000:f}\")\n        cap = ET.SubElement(main_protect, \"Cap\")\n        if protocol.safety.max_capacity_mAh:\n            ET.SubElement(cap, \"Upper\", Value=f\"{protocol.safety.max_capacity_mAh * 3600:f}\")\n\n        record = ET.SubElement(whole_prt, \"Record\")\n        main_record = ET.SubElement(record, \"Main\")\n        if protocol.record.time_s:\n            ET.SubElement(main_record, \"Time\", Value=f\"{protocol.record.time_s * 1000:f}\")\n        if protocol.record.voltage_V:\n            ET.SubElement(main_record, \"Volt\", Value=f\"{protocol.record.voltage_V * 10000:f}\")\n        if protocol.record.current_mA:\n            ET.SubElement(main_record, \"Curr\", Value=f\"{protocol.record.current_mA:f}\")\n\n        step_info = ET.SubElement(\n            config, \"Step_Info\", Num=str(len(protocol.method) + 1)\n        )  # +1 for end step\n\n        def _step_to_element(\n            step: AnyTechnique,\n            step_num: int,\n            parent: ET.Element,\n            prev_step: AnyTechnique | None = None,\n        ) -&gt; None:\n            \"\"\"Create XML subelement from protocol technique.\"\"\"\n            match step:\n                case ConstantCurrent():\n                    if step.rate_C is not None and step.rate_C != 0:\n                        step_type = \"1\" if step.rate_C &gt; 0 else \"2\"\n                    elif step.current_mA is not None and step.current_mA != 0:\n                        step_type = \"1\" if step.current_mA &gt; 0 else \"2\"\n                    else:\n                        msg = \"Must have a current or C-rate\"\n                        raise ValueError(msg)\n\n                    step_element = ET.SubElement(\n                        parent, f\"Step{step_num}\", Step_ID=str(step_num), Step_Type=step_type\n                    )\n                    limit = ET.SubElement(step_element, \"Limit\")\n                    main = ET.SubElement(limit, \"Main\")\n                    if step.rate_C is not None:\n                        assert protocol.sample.capacity_mAh is not None  # noqa: S101, from _validate_capacity_c_rates()\n                        ET.SubElement(main, \"Rate\", Value=f\"{abs(step.rate_C):f}\")\n                        ET.SubElement(\n                            main,\n                            \"Curr\",\n                            Value=f\"{abs(step.rate_C) * protocol.sample.capacity_mAh:f}\",\n                        )\n                    elif step.current_mA is not None:\n                        ET.SubElement(main, \"Curr\", Value=f\"{abs(step.current_mA):f}\")\n                    if step.until_time_s is not None:\n                        ET.SubElement(main, \"Time\", Value=f\"{step.until_time_s * 1000:f}\")\n                    if step.until_voltage_V is not None:\n                        ET.SubElement(main, \"Stop_Volt\", Value=f\"{step.until_voltage_V * 10000:f}\")\n\n                case ConstantVoltage():\n                    # Check if CV follows CC and has the same voltage cutoff\n                    prev_rate_C = None\n                    prev_current_mA = None\n                    if (\n                        isinstance(prev_step, ConstantCurrent)\n                        and prev_step.until_voltage_V == step.voltage_V\n                    ):\n                        if prev_step.rate_C is not None:\n                            assert protocol.sample.capacity_mAh is not None  # noqa: S101, from _validate_capacity_c_rates()\n                            prev_rate_C = abs(prev_step.rate_C)\n                            prev_current_mA = abs(prev_step.rate_C) * protocol.sample.capacity_mAh\n                        elif prev_step.current_mA is not None:\n                            prev_current_mA = abs(prev_step.current_mA)\n                    if step.until_rate_C is not None and step.until_rate_C != 0:\n                        step_type = \"3\" if step.until_rate_C &gt; 0 else \"19\"\n                    elif step.until_current_mA is not None and step.until_current_mA != 0:\n                        step_type = \"3\" if step.until_current_mA &gt; 0 else \"19\"\n                    else:\n                        step_type = \"3\"  # If it can't be figured out, default to charge\n                    step_element = ET.SubElement(\n                        parent, f\"Step{step_num}\", Step_ID=str(step_num), Step_Type=step_type\n                    )\n                    limit = ET.SubElement(step_element, \"Limit\")\n                    main = ET.SubElement(limit, \"Main\")\n                    ET.SubElement(main, \"Volt\", Value=f\"{step.voltage_V * 10000:f}\")\n                    if step.until_time_s is not None:\n                        ET.SubElement(main, \"Time\", Value=f\"{step.until_time_s * 1000:f}\")\n                    if step.until_rate_C is not None:\n                        assert protocol.sample.capacity_mAh is not None  # noqa: S101, from _validate_capacity_c_rates()\n                        ET.SubElement(main, \"Stop_Rate\", Value=f\"{abs(step.until_rate_C):f}\")\n                        ET.SubElement(\n                            main,\n                            \"Stop_Curr\",\n                            Value=f\"{abs(step.until_rate_C) * protocol.sample.capacity_mAh:f}\",\n                        )\n                    elif step.until_current_mA is not None:\n                        ET.SubElement(main, \"Stop_Curr\", Value=f\"{abs(step.until_current_mA):f}\")\n                    if prev_rate_C is not None:\n                        assert protocol.sample.capacity_mAh is not None  # noqa: S101, from _validate_capacity_c_rates()\n                        ET.SubElement(main, \"Rate\", Value=f\"{abs(prev_rate_C):f}\")\n                        ET.SubElement(\n                            main,\n                            \"Curr\",\n                            Value=f\"{abs(prev_rate_C) * protocol.sample.capacity_mAh:f}\",\n                        )\n                    elif prev_current_mA is not None:\n                        ET.SubElement(main, \"Curr\", Value=f\"{abs(prev_current_mA):f}\")\n\n                case OpenCircuitVoltage():\n                    step_element = ET.SubElement(\n                        parent, f\"Step{step_num}\", Step_ID=str(step_num), Step_Type=\"4\"\n                    )\n                    limit = ET.SubElement(step_element, \"Limit\")\n                    main = ET.SubElement(limit, \"Main\")\n                    ET.SubElement(main, \"Time\", Value=f\"{step.until_time_s * 1000:f}\")\n\n                case Loop():\n                    step_element = ET.SubElement(\n                        parent, f\"Step{step_num}\", Step_ID=str(step_num), Step_Type=\"5\"\n                    )\n                    limit = ET.SubElement(step_element, \"Limit\")\n                    other = ET.SubElement(limit, \"Other\")\n                    ET.SubElement(other, \"Start_Step\", Value=str(step.loop_to))\n                    ET.SubElement(other, \"Cycle_Count\", Value=str(step.cycle_count))\n\n                case _:\n                    msg = f\"to_neware_xml does not support step type: {step.step}\"\n                    raise TypeError(msg)\n\n        for i, technique in enumerate(protocol.method):\n            step_num = i + 1\n            prev_step = protocol.method[i - 1] if i &gt;= 1 else None\n            _step_to_element(technique, step_num, step_info, prev_step)\n\n        # Add an end step\n        step_num = len(protocol.method) + 1\n        ET.SubElement(step_info, f\"Step{step_num}\", Step_ID=str(step_num), Step_Type=\"6\")\n\n        smbus = ET.SubElement(config, \"SMBUS\")\n        ET.SubElement(smbus, \"SMBUS_Info\", Num=\"0\", AdjacentInterval=\"0\")\n\n        # Convert to string and prettify it\n        pretty_xml_string = minidom.parseString(ET.tostring(root)).toprettyxml(indent=\"  \")  # noqa: S318\n        if save_path:\n            save_path = Path(save_path)\n            save_path.parent.mkdir(parents=True, exist_ok=True)\n            with save_path.open(\"w\", encoding=\"utf-8\") as f:\n                f.write(pretty_xml_string)\n        return pretty_xml_string\n\n    def to_tomato_mpg2(\n        self,\n        save_path: Path | str | None = None,\n        tomato_output: Path = Path(\"C:/tomato_data/\"),\n        sample_name: str | None = None,\n        capacity_mAh: float | None = None,\n    ) -&gt; str:\n        \"\"\"Convert protocol to tomato 0.2.3 + MPG2 compatible JSON format.\n\n        Args:\n            save_path: (optional) File path of where to save the json file.\n            tomato_output: (optional) Where to save the data from tomato.\n            sample_name: (optional) Override the protocol sample name.\n            capacity_mAh: (optional) Override the protocol sample capacity.\n\n        Returns:\n            json string representation of the protocol.\n\n        \"\"\"\n        # Create and operate on a copy of the original object\n        protocol = self.model_copy()\n\n        # Allow overwriting name and capacity\n        if sample_name:\n            protocol.sample.name = sample_name\n        if capacity_mAh:\n            protocol.sample.capacity_mAh = capacity_mAh\n\n        # Make sure sample name is set\n        if not protocol.sample.name or protocol.sample.name == \"$NAME\":\n            msg = (\n                \"If using blank sample name or $NAME placeholder, \"\n                \"a sample name must be provided in this function.\"\n            )\n            raise ValueError(msg)\n\n        # Make sure capacity is set if using C-rate steps\n        protocol._validate_capacity_c_rates()\n\n        # Remove tags and convert to indices\n        protocol._tag_to_indices()\n        protocol._check_for_intersecting_loops()\n\n        # Create JSON structure\n        tomato_dict: dict = {\n            \"version\": \"0.1\",\n            \"sample\": {},\n            \"method\": [],\n            \"tomato\": {\n                \"unlock_when_done\": True,\n                \"verbosity\": \"DEBUG\",\n                \"output\": {\n                    \"path\": str(tomato_output),\n                    \"prefix\": protocol.sample.name,\n                },\n            },\n        }\n        # tomato -&gt; MPG2 does not support safety parameters, they are set in the instrument\n        tomato_dict[\"sample\"][\"name\"] = protocol.sample.name\n        tomato_dict[\"sample\"][\"capacity_mAh\"] = protocol.sample.capacity_mAh\n        for step in protocol.method:\n            tomato_step: dict = {}\n            tomato_step[\"device\"] = \"MPG2\"\n            tomato_step[\"technique\"] = step.step\n            if isinstance(step, (ConstantCurrent, ConstantVoltage, OpenCircuitVoltage)):\n                if protocol.record.time_s:\n                    tomato_step[\"measure_every_dt\"] = protocol.record.time_s\n                if protocol.record.current_mA:\n                    tomato_step[\"measure_every_dI\"] = protocol.record.current_mA\n                if protocol.record.voltage_V:\n                    tomato_step[\"measure_every_dE\"] = protocol.record.voltage_V\n                tomato_step[\"I_range\"] = \"10 mA\"\n                tomato_step[\"E_range\"] = \"+-5.0 V\"\n\n            match step:\n                case OpenCircuitVoltage():\n                    tomato_step[\"time\"] = step.until_time_s\n\n                case ConstantCurrent():\n                    if step.rate_C:\n                        if step.rate_C &gt; 0:\n                            charging = True\n                            tomato_step[\"current\"] = str(step.rate_C) + \"C\"\n                        else:\n                            charging = False\n                            tomato_step[\"current\"] = str(abs(step.rate_C)) + \"D\"\n                    elif step.current_mA:\n                        if step.current_mA &gt; 0:\n                            charging = True\n                            tomato_step[\"current\"] = step.current_mA / 1000\n                        else:\n                            charging = False\n                            tomato_step[\"current\"] = step.current_mA / 1000\n                    else:\n                        msg = \"Must have a current or C-rate\"\n                        raise ValueError(msg)\n                    if step.until_time_s:\n                        tomato_step[\"time\"] = step.until_time_s\n                    if step.until_voltage_V:\n                        if charging:\n                            tomato_step[\"limit_voltage_max\"] = step.until_voltage_V\n                        else:\n                            tomato_step[\"limit_voltage_min\"] = step.until_voltage_V\n\n                case ConstantVoltage():\n                    tomato_step[\"voltage\"] = step.voltage_V\n                    if step.until_time_s:\n                        tomato_step[\"time\"] = step.until_time_s\n                    if step.until_rate_C:\n                        if step.until_rate_C &gt; 0:\n                            tomato_step[\"limit_current_min\"] = str(step.until_rate_C) + \"C\"\n                        else:\n                            tomato_step[\"limit_current_max\"] = str(abs(step.until_rate_C)) + \"D\"\n\n                case Loop():\n                    assert isinstance(step.loop_to, int)  # noqa: S101, from _tag_to_indices()\n                    tomato_step[\"goto\"] = step.loop_to - 1  # 0-indexed in mpr\n                    tomato_step[\"n_gotos\"] = step.cycle_count - 1  # gotos is one less than cycles\n\n                case _:\n                    msg = f\"to_tomato_mpg2 does not support step type: {step.step}\"\n                    raise TypeError(msg)\n\n            tomato_dict[\"method\"].append(tomato_step)\n\n        if save_path:\n            save_path = Path(save_path)\n            save_path.parent.mkdir(parents=True, exist_ok=True)\n            with save_path.open(\"w\", encoding=\"utf-8\") as f:\n                json.dump(tomato_dict, f, indent=4)\n        return json.dumps(tomato_dict, indent=4)\n\n    def to_pybamm_experiment(self) -&gt; list[str]:\n        \"\"\"Convert protocol to PyBaMM experiment format.\n\n        A PyBaMM experiment does not need capacity or sample name.\n\n        Returns:\n            list of strings representing the PyBaMM experiment.\n\n        \"\"\"\n        # Don't need to validate capacity if using C-rate steps\n        # Create and operate on a copy of the original object\n        protocol = self.model_copy()\n\n        # Remove tags and convert to indices\n        protocol._tag_to_indices()\n        protocol._check_for_intersecting_loops()\n\n        pybamm_experiment: list[str] = []\n        loops: dict[int, dict] = {}\n        for i, step in enumerate(protocol.method):\n            step_str = \"\"\n            match step:\n                case ConstantCurrent():\n                    if step.rate_C:\n                        if step.rate_C &gt; 0:\n                            step_str += f\"Charge at {step.rate_C}C\"\n                        else:\n                            step_str += f\"Discharge at {abs(step.rate_C)}C\"\n                    elif step.current_mA:\n                        if step.current_mA &gt; 0:\n                            step_str += f\"Charge at {step.current_mA} mA\"\n                        else:\n                            step_str += f\"Discharge at {abs(step.current_mA)} mA\"\n                    if step.until_time_s:\n                        if step.until_time_s % 3600 == 0:\n                            step_str += f\" for {int(step.until_time_s / 3600)} hours\"\n                        elif step.until_time_s % 60 == 0:\n                            step_str += f\" for {int(step.until_time_s / 60)} minutes\"\n                        else:\n                            step_str += f\" for {step.until_time_s} seconds\"\n                    if step.until_voltage_V:\n                        step_str += f\" until {step.until_voltage_V} V\"\n\n                case ConstantVoltage():\n                    step_str += f\"Hold at {step.voltage_V} V\"\n                    conditions = []\n                    if step.until_time_s:\n                        if step.until_time_s % 3600 == 0:\n                            step_str += f\" for {int(step.until_time_s / 3600)} hours\"\n                        elif step.until_time_s % 60 == 0:\n                            step_str += f\" for {int(step.until_time_s / 60)} minutes\"\n                        else:\n                            conditions.append(f\"for {step.until_time_s} seconds\")\n                    if step.until_rate_C:\n                        conditions.append(f\"until {step.until_rate_C}C\")\n                    if step.until_current_mA:\n                        conditions.append(f\" until {step.until_current_mA} mA\")\n                    if conditions:\n                        step_str += \" \" + \" or \".join(conditions)\n\n                case OpenCircuitVoltage():\n                    step_str += f\"Rest for {step.until_time_s} seconds\"\n\n                case Loop():\n                    # The string from this will get dropped later\n                    assert isinstance(step.loop_to, int)  # noqa: S101, from _tag_to_indices()\n                    loops[i] = {\"goto\": step.loop_to - 1, \"n\": step.cycle_count, \"n_done\": 0}\n\n                case _:\n                    msg = f\"to_pybamm_experiment does not support step type: {step.step}\"\n                    raise TypeError(msg)\n\n            pybamm_experiment.append(step_str)\n\n        exploded_steps = []\n        i = 0\n        total_itr = 0\n        while i &lt; len(pybamm_experiment):\n            exploded_steps.append(i)\n            if i in loops and loops[i][\"n_done\"] &lt; loops[i][\"n\"]:\n                # check if it passes over a different loop, if so reset its count\n                for j in loops:  # noqa: PLC0206\n                    if j &lt; i and j &gt;= loops[i][\"goto\"]:\n                        loops[j][\"n_done\"] = 0\n                loops[i][\"n_done\"] += 1\n                i = loops[i][\"goto\"]\n            else:\n                i += 1\n            total_itr += 1\n            if total_itr &gt; 10000:\n                msg = (\n                    \"Over 10000 steps in protocol to_pybamm_experiment(), \"\n                    \"likely a loop definition error.\"\n                )\n                raise RuntimeError(msg)\n\n        # remove all loop steps from the list\n        cleaned_exploded_steps = [i for i in exploded_steps if i not in loops]\n        # change from list of indices to list of strings\n        return [pybamm_experiment[i] for i in cleaned_exploded_steps]\n\n    def to_biologic_mps(\n        self,\n        save_path: Path | str | None = None,\n        sample_name: str | None = None,\n        capacity_mAh: float | None = None,\n    ) -&gt; str:\n        \"\"\"Convert protocol to a Biologic Settings file (.mps).\n\n        Uses the ModuloBatt technique.\n\n        Note that you must add OCV steps inbetween CC/CV steps if you want the\n        current range to be able to change.\n\n        Args:\n            save_path: (optional) File path of where to save the mps file.\n            sample_name: (optional) Override the protocol sample name.\n            capacity_mAh: (optional) Override the protocol sample capacity.\n\n        Returns:\n            mps string representation of the protocol.\n\n        \"\"\"\n        # Create and operate on a copy of the original object\n        protocol = self.model_copy()\n\n        # Allow overwriting name and capacity\n        if sample_name:\n            protocol.sample.name = sample_name\n        if capacity_mAh:\n            protocol.sample.capacity_mAh = capacity_mAh\n\n        # Make sure sample name is set\n        if not protocol.sample.name or protocol.sample.name == \"$NAME\":\n            msg = (\n                \"If using blank sample name or $NAME placeholder, \"\n                \"a sample name must be provided in this function.\"\n            )\n            raise ValueError(msg)\n\n        # Make sure capacity is set if using C-rate steps\n        protocol._validate_capacity_c_rates()\n\n        # Remove tags and convert to indices\n        protocol._tag_to_indices()\n        protocol._check_for_intersecting_loops()\n\n        header = [\n            \"EC-LAB SETTING FILE\",\n            \"\",\n            \"Number of linked techniques : 1\",\n            \"Device : MPG-2\",\n            \"CE vs. WE compliance from -10 V to 10 V\",\n            \"Electrode connection : standard\",\n            \"Potential control : Ewe\",\n            \"Ewe ctrl range : min = 0.00 V, max = 5.00 V\",\n            \"Safety Limits :\",\n            \"\tDo not start on E overload\",\n            f\"Comments : {protocol.sample.name}\",\n            \"Cycle Definition : Charge/Discharge alternance\",\n            \"Do not turn to OCV between techniques\",\n            \"\",\n            \"Technique : 1\",\n            \"Modulo Bat\",\n        ]\n\n        default_step = {\n            \"Ns\": \"\",\n            \"ctrl_type\": \"\",\n            \"Apply I/C\": \"I\",\n            \"current/potential\": \"current\",\n            \"ctrl1_val\": \"\",\n            \"ctrl1_val_unit\": \"\",\n            \"ctrl1_val_vs\": \"\",\n            \"ctrl2_val\": \"\",\n            \"ctrl2_val_unit\": \"\",\n            \"ctrl2_val_vs\": \"\",\n            \"ctrl3_val\": \"\",\n            \"ctrl3_val_unit\": \"\",\n            \"ctrl3_val_vs\": \"\",\n            \"N\": \"0.00\",\n            \"charge/discharge\": \"Charge\",\n            \"charge/discharge_1\": \"Charge\",\n            \"Apply I/C_1\": \"I\",\n            \"N1\": \"0.00\",\n            \"ctrl4_val\": \"\",\n            \"ctrl4_val_unit\": \"\",\n            \"ctrl5_val\": \"\",\n            \"ctrl5_val_unit\": \"\",\n            \"ctrl_tM\": \"0\",\n            \"ctrl_seq\": \"0\",\n            \"ctrl_repeat\": \"0\",\n            \"ctrl_trigger\": \"Falling Edge\",\n            \"ctrl_TO_t\": \"0.000\",\n            \"ctrl_TO_t_unit\": \"d\",\n            \"ctrl_Nd\": \"6\",\n            \"ctrl_Na\": \"2\",\n            \"ctrl_corr\": \"0\",\n            \"lim_nb\": \"0\",\n            \"lim1_type\": \"Time\",\n            \"lim1_comp\": \"&gt;\",\n            \"lim1_Q\": \"\",\n            \"lim1_value\": \"0.000\",\n            \"lim1_value_unit\": \"s\",\n            \"lim1_action\": \"Next sequence\",\n            \"lim1_seq\": \"\",\n            \"lim2_type\": \"\",\n            \"lim2_comp\": \"\",\n            \"lim2_Q\": \"\",\n            \"lim2_value\": \"\",\n            \"lim2_value_unit\": \"\",\n            \"lim2_action\": \"Next sequence\",\n            \"lim2_seq\": \"\",\n            \"rec_nb\": \"0\",\n            \"rec1_type\": \"\",\n            \"rec1_value\": \"\",\n            \"rec1_value_unit\": \"\",\n            \"rec2_type\": \"\",\n            \"rec2_value\": \"\",\n            \"rec2_value_unit\": \"\",\n            \"E range min (V)\": \"0.000\",\n            \"E range max (V)\": \"5.000\",\n            \"I Range\": \"Auto\",\n            \"I Range min\": \"Unset\",\n            \"I Range max\": \"Unset\",\n            \"I Range init\": \"Unset\",\n            \"auto rest\": \"1\",\n            \"Bandwidth\": \"5\",\n        }\n\n        # Use fixed I range for CC and GEIS steps, Auto otherwise\n        # There is no Auto option for CC or GEIS\n        I_ranges_mA = {\n            0.01: \"10 \u00b5A\",\n            0.1: \"100 \u00b5A\",\n            1: \"1 mA\",\n            10: \"10 mA\",\n            100: \"100 mA\",\n        }\n\n        # Make a list of dicts, one for each step\n        step_dicts = []\n        for i, step in enumerate(protocol.method):\n            step_dict = default_step.copy()\n            step_dict.update(\n                {\n                    \"Ns\": str(i),\n                    \"lim1_seq\": str(i + 1),\n                    \"lim2_seq\": str(i + 1),\n                },\n            )\n            match step:\n                case OpenCircuitVoltage():\n                    step_dict.update(\n                        {\n                            \"ctrl_type\": \"Rest\",\n                            \"lim_nb\": \"1\",\n                            \"lim1_type\": \"Time\",\n                            \"lim1_comp\": \"&gt;\",\n                            \"lim1_value\": f\"{step.until_time_s:.3f}\",\n                            \"lim1_value_unit\": \"s\",\n                            \"rec_nb\": \"1\",\n                            \"rec1_type\": \"Time\",\n                            \"rec1_value\": f\"{protocol.record.time_s or 0:.3f}\",\n                            \"rec1_value_unit\": \"s\",\n                        },\n                    )\n\n                case ConstantCurrent():\n                    if step.rate_C and protocol.sample.capacity_mAh:\n                        current_mA = step.rate_C * protocol.sample.capacity_mAh\n                    elif step.current_mA:\n                        current_mA = step.current_mA\n                    else:\n                        msg = \"Either rate_C or current_mA must be set for ConstantCurrent step.\"\n                        raise ValueError(msg)\n\n                    if abs(current_mA) &lt; 1:\n                        step_dict.update(\n                            {\n                                \"ctrl_type\": \"CC\",\n                                \"ctrl1_val\": f\"{current_mA * 1e3:.3f}\",\n                                \"ctrl1_val_unit\": \"uA\",\n                                \"ctrl1_val_vs\": \"&lt;None&gt;\",\n                            },\n                        )\n                    else:\n                        step_dict.update(\n                            {\n                                \"ctrl_type\": \"CC\",\n                                \"ctrl1_val\": f\"{current_mA:.3f}\",\n                                \"ctrl1_val_unit\": \"mA\",\n                                \"ctrl1_val_vs\": \"&lt;None&gt;\",\n                            },\n                        )\n                    for val, range_str in I_ranges_mA.items():\n                        if abs(current_mA) &lt;= val:\n                            step_dict.update({\"I Range\": range_str})\n                            break\n                    else:\n                        msg = f\"I range not supported for {current_mA} mA\"\n                        raise ValueError(msg)\n\n                    # Add limit details\n                    lim_num = 0\n                    if step.until_time_s:\n                        lim_num += 1\n                        step_dict.update(\n                            {\n                                f\"lim{lim_num}_type\": \"Time\",\n                                f\"lim{lim_num}_comp\": \"&gt;\",\n                                f\"lim{lim_num}_value\": f\"{step.until_time_s:.3f}\",\n                                f\"lim{lim_num}_value_unit\": \"s\",\n                            },\n                        )\n                    if step.until_voltage_V:\n                        lim_num += 1\n                        comp = \"&gt;\" if current_mA &gt; 0 else \"&lt;\"\n                        step_dict.update(\n                            {\n                                f\"lim{lim_num}_type\": \"Ewe\",\n                                f\"lim{lim_num}_comp\": comp,\n                                f\"lim{lim_num}_value\": f\"{step.until_voltage_V:.3f}\",\n                                f\"lim{lim_num}_value_unit\": \"V\",\n                            },\n                        )\n                    step_dict.update(\n                        {\n                            \"lim_nb\": str(lim_num),\n                        },\n                    )\n\n                    # Add record details\n                    rec_num = 0\n                    if protocol.record.time_s:\n                        rec_num += 1\n                        step_dict.update(\n                            {\n                                f\"rec{rec_num}_type\": \"Time\",\n                                f\"rec{rec_num}_value\": f\"{protocol.record.time_s:.3f}\",\n                                f\"rec{rec_num}_value_unit\": \"s\",\n                            },\n                        )\n                    if protocol.record.voltage_V:\n                        rec_num += 1\n                        step_dict.update(\n                            {\n                                f\"rec{rec_num}_type\": \"Ewe\",\n                                f\"rec{rec_num}_value\": f\"{protocol.record.voltage_V:.3f}\",\n                                f\"rec{rec_num}_value_unit\": \"V\",\n                            },\n                        )\n                    step_dict.update(\n                        {\n                            \"rec_nb\": str(rec_num),\n                        },\n                    )\n\n                case ConstantVoltage():\n                    step_dict.update(\n                        {\n                            \"ctrl_type\": \"CV\",\n                            \"ctrl1_val\": f\"{step.voltage_V:.3f}\",\n                            \"ctrl1_val_unit\": \"V\",\n                            \"ctrl1_val_vs\": \"Ref\",\n                        },\n                    )\n\n                    # Add limit details\n                    lim_num = 0\n                    if step.until_time_s:\n                        lim_num += 1\n                        step_dict.update(\n                            {\n                                f\"lim{lim_num}_type\": \"Time\",\n                                f\"lim{lim_num}_comp\": \"&gt;\",\n                                f\"lim{lim_num}_value\": f\"{step.until_time_s:.3f}\",\n                                f\"lim{lim_num}_value_unit\": \"s\",\n                            },\n                        )\n                    if step.until_rate_C and protocol.sample.capacity_mAh:\n                        until_mA = step.until_rate_C * protocol.sample.capacity_mAh\n                    elif step.until_current_mA:\n                        until_mA = step.until_current_mA\n                    else:\n                        until_mA = None\n                    if until_mA:\n                        lim_num += 1\n                        step_dict.update(\n                            {\n                                f\"lim{lim_num}_type\": \"|I|\",\n                                f\"lim{lim_num}_comp\": \"&lt;\",\n                                f\"lim{lim_num}_value\": f\"{abs(until_mA):.3f}\",\n                                f\"lim{lim_num}_value_unit\": \"mA\",\n                            },\n                        )\n                    step_dict.update(\n                        {\n                            \"lim_nb\": str(lim_num),\n                        },\n                    )\n                    if i &gt; 0:\n                        prev_mA = None\n                        prev_step = protocol.method[i - 1]\n                        if isinstance(prev_step, ConstantCurrent):\n                            prev_mA = None\n                            if prev_step.rate_C and protocol.sample.capacity_mAh:\n                                prev_mA = prev_step.rate_C * protocol.sample.capacity_mAh\n                            elif prev_step.current_mA:\n                                prev_mA = prev_step.current_mA\n                            if prev_mA and prev_step.until_voltage_V == step.voltage_V:\n                                for val, range_str in I_ranges_mA.items():\n                                    if abs(prev_mA) &lt;= val:\n                                        step_dict.update({\"I Range\": range_str})\n                                        break\n\n                    # Add record details\n                    rec_num = 0\n                    if protocol.record.time_s:\n                        rec_num += 1\n                        step_dict.update(\n                            {\n                                f\"rec{rec_num}_type\": \"Time\",\n                                f\"rec{rec_num}_value\": f\"{protocol.record.time_s:.3f}\",\n                                f\"rec{rec_num}_value_unit\": \"s\",\n                            },\n                        )\n                    if protocol.record.current_mA:\n                        rec_num += 1\n                        step_dict.update(\n                            {\n                                f\"rec{rec_num}_type\": \"I\",\n                                f\"rec{rec_num}_value\": f\"{protocol.record.current_mA:.3f}\",\n                                f\"rec{rec_num}_value_unit\": \"mA\",\n                            },\n                        )\n                    step_dict.update(\n                        {\n                            \"rec_nb\": str(rec_num),\n                        },\n                    )\n\n                case ImpedanceSpectroscopy():\n                    if step.amplitude_V:\n                        step_dict.update({\"ctrl_type\": \"PEIS\"})\n                        if step.amplitude_V &gt;= 0.1:\n                            step_dict.update({\"ctrl1_val\": f\"{step.amplitude_V:.3f}\"})\n                            step_dict.update({\"ctrl1_val_unit\": \"V\"})\n                        elif step.amplitude_V &gt;= 0.001:\n                            step_dict.update({\"ctrl1_val\": f\"{step.amplitude_V * 1e3:.3f}\"})\n                            step_dict.update({\"ctrl1_val_unit\": \"mV\"})\n                        else:\n                            step_dict.update({\"ctrl1_val\": f\"{step.amplitude_V * 1e6:.3f}\"})\n                            step_dict.update({\"ctrl1_val_unit\": \"uV\"})\n\n                    elif step.amplitude_mA:\n                        step_dict.update({\"ctrl_type\": \"GEIS\"})\n                        if step.amplitude_mA &gt;= 1000:\n                            step_dict.update({\"ctrl1_val\": f\"{step.amplitude_mA / 1000:.3f}\"})\n                            step_dict.update({\"ctrl1_val_unit\": \"A\"})\n                        elif step.amplitude_mA &gt;= 1:\n                            step_dict.update({\"ctrl1_val\": f\"{step.amplitude_mA:.3f}\"})\n                            step_dict.update({\"ctrl1_val_unit\": \"mA\"})\n                        else:\n                            step_dict.update({\"ctrl1_val\": f\"{step.amplitude_mA * 1000:.3f}\"})\n                            step_dict.update({\"ctrl1_val_unit\": \"uA\"})\n\n                        for val, range_str in I_ranges_mA.items():\n                            # GEIS I range behaves differently to CC\n                            # 1 mA range means 0.5 mA max amplitude\n                            if abs(step.amplitude_mA) * 2 &lt;= val:\n                                step_dict.update({\"I Range\": range_str})\n                                break\n                        else:\n                            msg = f\"I range not supported for {step.amplitude_mA} mA\"\n                            raise ValueError(msg)\n\n                    else:\n                        msg = \"Either amplitude_V or amplitude_mA must be set.\"\n                        raise ValueError(msg)\n\n                    for freq, ctrl in ((step.start_frequency_Hz, 2), (step.end_frequency_Hz, 3)):\n                        if freq &gt;= 1e3:\n                            step_dict.update({f\"ctrl{ctrl}_val\": f\"{freq / 1e3:.3f}\"})\n                            step_dict.update({f\"ctrl{ctrl}_val_unit\": \"kHz\"})\n                        elif freq &gt;= 1:\n                            step_dict.update({f\"ctrl{ctrl}_val\": f\"{freq:.3f}\"})\n                            step_dict.update({f\"ctrl{ctrl}_val_unit\": \"Hz\"})\n                        elif freq &gt;= 1e-3:\n                            step_dict.update({f\"ctrl{ctrl}_val\": f\"{freq * 1e3:.3f}\"})\n                            step_dict.update({f\"ctrl{ctrl}_val_unit\": \"mHz\"})\n                    step_dict.update(\n                        {\n                            \"ctrl_Nd\": f\"{step.points_per_decade}\",\n                            \"ctrl_Na\": f\"{step.measures_per_point}\",\n                            \"ctrl_corr\": f\"{1 if step.drift_correction is True else 0}\",\n                        }\n                    )\n\n                case Loop():\n                    assert isinstance(step.loop_to, int)  # noqa: S101, from _tag_to_indices()\n                    step_dict.update(\n                        {\n                            \"ctrl_type\": \"Loop\",\n                            \"ctrl_seq\": str(step.loop_to - 1),  # 0-indexed here\n                            \"ctrl_repeat\": str(\n                                step.cycle_count - 1\n                            ),  # cycles is one less than n_gotos\n                        },\n                    )\n\n                case _:\n                    msg = f\"to_biologic_mps() does not support step type: {step.step}\"\n                    raise NotImplementedError(msg)\n\n            step_dicts.append(step_dict)\n\n        # Transform list of dicts into list of strings\n        # Each row is one key and all values of each step\n        # All elements must be 20 characters wide\n        rows = []\n        for row_header in default_step:\n            row_data = [step[row_header] for step in step_dicts]\n            rows.append(row_header.ljust(20) + \"\".join(d.ljust(20) for d in row_data))\n\n        settings_string = \"\\n\".join([*header, *rows, \"\"])\n\n        if save_path:\n            save_path = Path(save_path)\n            save_path.parent.mkdir(parents=True, exist_ok=True)\n            with save_path.open(\"w\", encoding=\"cp1252\") as f:\n                f.write(settings_string)\n\n        return settings_string\n\n    def to_battinfo_jsonld(\n        self,\n        save_path: Path | str | None = None,\n        capacity_mAh: float | None = None,\n        *,\n        include_context: bool = False,\n    ) -&gt; dict:\n        \"\"\"Convert protocol to BattInfo JSON-LD format.\n\n        This generates the 'hasTask' key in BattINFO, and does not include the\n        creator, lab, instrument etc.\n\n        Args:\n            save_path: (optional) File path of where to save the JSON-LD file.\n            capacity_mAh: (optional) Override the protocol sample capacity.\n            include_context: (optional) Add a `@context` key to the root of the\n                JSON-LD.\n\n        Returns:\n            Dictionary representation of the JSON-LD.\n\n        \"\"\"\n\n        def group_iterative_tasks(\n            step_numbers: list[int], method: Sequence[AnyTechnique]\n        ) -&gt; list[int | tuple[int, list]]:\n            \"\"\"Take a list of techniques, find the iterative loops.\n\n            Returns a list containing ints (a task) or a tuple of an int and\n            list (an iterative workflow).\n\n            E.g. [0,1,2,(1000, [4,5,6])]\n            Means do tasks 0, 1, 2, then loop over 4, 5, 6 1000 times.\n            \"\"\"\n            # Either this is surprisingly complex, or I am just stupid\n            # Assume there are no intersecting loops and tags are removed\n            # Must iterate BACKWARDS over techniques and treat loops recursively\n\n            tasks: list[int | tuple[int, list]] = []\n            skip_above: int | None = None\n\n            list_indices = list(range(len(method)))\n\n            for i, step_number in zip(reversed(list_indices), reversed(step_numbers), strict=True):\n                # If the techniques are already included in a loop at a higher depth, skip\n                if skip_above and step_numbers[i] &gt;= skip_above:\n                    continue\n\n                # If the technique is a loop, the whole loop goes inside a tuple\n                if isinstance(method[i], Loop):\n                    loop_object = method[i]\n                    assert isinstance(loop_object, Loop)  # noqa: S101\n                    assert isinstance(loop_object.loop_to, int)  # noqa: S101\n                    cycle_count = loop_object.cycle_count\n                    start_step: int = loop_object.loop_to - 1  # because loop_to is 1-indexed\n\n                    # Find the subsection that the loop belongs to\n                    start_i = next(j for j, n in enumerate(step_numbers) if n == start_step)\n                    end_i = i\n\n                    # Add this element, recursively run this function on the loops subsection\n                    tasks.append(\n                        (\n                            cycle_count,\n                            group_iterative_tasks(\n                                step_numbers[start_i:end_i], method[start_i:end_i]\n                            ),\n                        ),\n                    )\n\n                    # Skip the rest of the loop at this depth\n                    skip_above = start_step\n                else:\n                    # Just add the technique\n                    tasks.append(step_number)\n            return tasks[::-1]\n\n        def battinfoify_technique(step: AnyTechnique, capacity_mAh: float | None) -&gt; dict:\n            \"\"\"Create a single BattINFO dict from a technique.\"\"\"\n            match step:\n                case OpenCircuitVoltage():\n                    tech_dict = {\n                        \"@type\": \"Resting\",\n                        \"hasInput\": [\n                            {\n                                \"@type\": \"Duration\",\n                                \"hasNumericalPart\": {\n                                    \"@type\": \"RealData\",\n                                    \"hasNumberValue\": step.until_time_s,\n                                },\n                                \"hasMeasurementUnit\": \"Second\",\n                            }\n                        ],\n                    }\n                case ConstantCurrent():\n                    inputs = []\n                    current_mA: float | None = None\n                    if step.rate_C and capacity_mAh:\n                        current_mA = step.rate_C * capacity_mAh\n                    elif step.current_mA:\n                        current_mA = step.current_mA\n                    charging = (current_mA and current_mA &gt; 0) or (step.rate_C and step.rate_C &gt; 0)\n                    if current_mA:\n                        inputs.append(\n                            {\n                                \"@type\": \"ElectricCurrent\",\n                                \"hasNumericalPart\": {\n                                    \"@type\": \"RealData\",\n                                    \"hasNumberValue\": abs(current_mA),\n                                },\n                                \"hasMeasurementUnit\": \"MilliAmpere\",\n                            },\n                        )\n                    if step.rate_C:\n                        inputs.append(\n                            {\n                                \"@type\": \"CRate\",\n                                \"hasNumericalPart\": {\n                                    \"@type\": \"RealData\",\n                                    \"hasNumberValue\": abs(step.rate_C),\n                                },\n                                \"hasMeasurementUnit\": \"CRateUnit\",\n                            },\n                        )\n                    if step.until_voltage_V:\n                        inputs.append(\n                            {\n                                \"@type\": [\n                                    \"UpperVoltageLimit\" if charging else \"LowerVoltageLimit\",\n                                    \"TerminationQuantity\",\n                                ],\n                                \"hasNumericalPart\": {\n                                    \"@type\": \"RealData\",\n                                    \"hasNumberValue\": step.until_voltage_V,\n                                },\n                                \"hasMeasurementUnit\": \"Volt\",\n                            }\n                        )\n                    if step.until_time_s:\n                        inputs.append(\n                            {\n                                \"@type\": \"Duration\",\n                                \"hasNumericalPart\": {\n                                    \"@type\": \"RealData\",\n                                    \"hasNumberValue\": step.until_time_s,\n                                },\n                                \"hasMeasurementUnit\": \"Second\",\n                            }\n                        )\n                    tech_dict = {\n                        \"@type\": \"Charging\" if charging else \"Discharging\",\n                        \"hasInput\": inputs,\n                    }\n                case ConstantVoltage():\n                    inputs = [\n                        {\n                            \"@type\": \"Voltage\",\n                            \"hasNumericalPart\": {\n                                \"@type\": \"RealData\",\n                                \"hasNumberValue\": step.voltage_V,\n                            },\n                            \"hasMeasurementUnit\": \"Volt\",\n                        }\n                    ]\n                    until_current_mA: None | float = None\n                    if step.until_rate_C and capacity_mAh:\n                        until_current_mA = step.until_rate_C * capacity_mAh\n                    elif step.until_current_mA:\n                        until_current_mA = step.until_current_mA\n                    if until_current_mA is not None:\n                        inputs.append(\n                            {\n                                \"@type\": [\"LowerCurrentLimit\", \"TerminationQuantity\"],\n                                \"hasNumericalPart\": {\n                                    \"@type\": \"RealData\",\n                                    \"hasNumberValue\": abs(until_current_mA),\n                                },\n                                \"hasMeasurementUnit\": \"MilliAmpere\",\n                            }\n                        )\n                    if step.until_rate_C:\n                        inputs.append(\n                            {\n                                \"@type\": [\"LowerCRateLimit\", \"TerminationQuantity\"],\n                                \"hasNumericalPart\": {\n                                    \"@type\": \"RealData\",\n                                    \"hasNumberValue\": abs(step.until_rate_C),\n                                },\n                                \"hasMeasurementUnit\": \"CRateUnit\",\n                            },\n                        )\n                    if step.until_time_s:\n                        inputs.append(\n                            {\n                                \"@type\": \"Duration\",\n                                \"hasNumericalPart\": {\n                                    \"@type\": \"RealData\",\n                                    \"hasNumberValue\": step.until_time_s,\n                                },\n                                \"hasMeasurementUnit\": \"Second\",\n                            }\n                        )\n                    tech_dict = {\n                        \"@type\": \"Hold\",\n                        \"hasInput\": inputs,\n                    }\n                case _:\n                    msg = f\"Technique {step.step} not supported by to_battinfo_jsonld()\"\n                    raise NotImplementedError(msg)\n            return tech_dict\n\n        def recursive_battinfo_build(\n            order: list[int | tuple[int, list]],\n            methods: Sequence[AnyTechnique],\n            capacity_mAh: float | None,\n        ) -&gt; dict:\n            \"\"\"Recursively build the a BattINFO JSON-LD from a method.\"\"\"\n            if isinstance(order[0], int):\n                # It is just a normal techqniue\n                this_tech = battinfoify_technique(methods[order[0]], capacity_mAh)\n            else:\n                # It is an iterative workflow\n                assert isinstance(order[0], tuple)  # noqa: S101\n                this_tech = {\n                    \"@type\": \"IterativeWorkflow\",\n                    \"hasInput\": [\n                        {\n                            \"@type\": \"NumberOfIterations\",\n                            \"hasNumericalPart\": {\n                                \"@type\": \"RealData\",\n                                \"hasNumberValue\": order[0][0],\n                            },\n                            \"hasMeasurementUnit\": \"UnitOne\",\n                        }\n                    ],\n                    \"hasTask\": recursive_battinfo_build(order[0][1], methods, capacity_mAh),\n                }\n\n            # If there is another technique, keep going\n            if len(order) &gt; 1:\n                this_tech[\"hasNext\"] = recursive_battinfo_build(order[1:], methods, capacity_mAh)\n            return this_tech\n\n        # Create and operate on a copy of the original object\n        protocol = self.model_copy()\n\n        # Allow overwriting capacity\n        if capacity_mAh:\n            protocol.sample.capacity_mAh = capacity_mAh\n\n        # Make sure there are no tags or interecting loops\n        protocol._tag_to_indices()\n        protocol._check_for_intersecting_loops()\n\n        # Get the order of techniques with nested loops\n        battinfo_order = group_iterative_tasks(list(range(len(protocol.method))), protocol.method)\n\n        # Build the battinfo JSON-LD\n        battinfo_dict = recursive_battinfo_build(\n            battinfo_order, protocol.method, protocol.sample.capacity_mAh\n        )\n\n        # Include context at this level, if requested\n        if include_context:\n            battinfo_dict[\"@context\"] = [\n                \"https://w3id.org/emmo/domain/battery/context\",\n            ]\n\n        # Optionally save\n        if save_path:\n            save_path = Path(save_path)\n            save_path.parent.mkdir(parents=True, exist_ok=True)\n            with save_path.open(\"w\", encoding=\"utf-8\") as f:\n                json.dump(battinfo_dict, f, indent=4)\n\n        return battinfo_dict\n\n    @classmethod\n    def from_dict(\n        cls,\n        data: dict,\n        sample_name: str | None = None,\n        sample_capacity_mAh: float | None = None,\n    ) -&gt; \"Protocol\":\n        \"\"\"Create a Protocol instance from a dictionary.\"\"\"\n        # If values given then overwrite\n        data.setdefault(\"sample\", {})\n        if sample_name:\n            data[\"sample\"][\"name\"] = sample_name\n        if sample_capacity_mAh:\n            data[\"sample\"][\"capacity_mAh\"] = sample_capacity_mAh\n        return Protocol(**data)\n\n    @classmethod\n    def from_json(\n        cls,\n        json_file: str | Path,\n        sample_name: str | None = None,\n        sample_capacity_mAh: float | None = None,\n    ) -&gt; \"Protocol\":\n        \"\"\"Create a Protocol instance from a JSON file.\"\"\"\n        json_file = Path(json_file)\n        with json_file.open(\"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n        return cls.from_dict(data, sample_name, sample_capacity_mAh)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert a Protocol instance to a dictionary.\"\"\"\n        return self.model_dump()\n\n    def to_json(self, json_file: str | Path | None = None, indent: int = 4) -&gt; str:\n        \"\"\"Dump model as JSON string, optionally save as a JSON file.\"\"\"\n        json_string = self.model_dump_json(indent=indent)\n        if json_file:\n            json_file = Path(json_file)\n            json_file.parent.mkdir(parents=True, exist_ok=True)\n            with json_file.open(\"w\", encoding=\"utf-8\") as f:\n                f.write(json_string)\n        return json_string\n</code></pre>"},{"location":"api/#aurora_unicycler.Protocol.from_dict","title":"<code>from_dict(data, sample_name=None, sample_capacity_mAh=None)</code>  <code>classmethod</code>","text":"<p>Create a Protocol instance from a dictionary.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls,\n    data: dict,\n    sample_name: str | None = None,\n    sample_capacity_mAh: float | None = None,\n) -&gt; \"Protocol\":\n    \"\"\"Create a Protocol instance from a dictionary.\"\"\"\n    # If values given then overwrite\n    data.setdefault(\"sample\", {})\n    if sample_name:\n        data[\"sample\"][\"name\"] = sample_name\n    if sample_capacity_mAh:\n        data[\"sample\"][\"capacity_mAh\"] = sample_capacity_mAh\n    return Protocol(**data)\n</code></pre>"},{"location":"api/#aurora_unicycler.Protocol.from_json","title":"<code>from_json(json_file, sample_name=None, sample_capacity_mAh=None)</code>  <code>classmethod</code>","text":"<p>Create a Protocol instance from a JSON file.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>@classmethod\ndef from_json(\n    cls,\n    json_file: str | Path,\n    sample_name: str | None = None,\n    sample_capacity_mAh: float | None = None,\n) -&gt; \"Protocol\":\n    \"\"\"Create a Protocol instance from a JSON file.\"\"\"\n    json_file = Path(json_file)\n    with json_file.open(\"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n    return cls.from_dict(data, sample_name, sample_capacity_mAh)\n</code></pre>"},{"location":"api/#aurora_unicycler.Protocol.to_battinfo_jsonld","title":"<code>to_battinfo_jsonld(save_path=None, capacity_mAh=None, *, include_context=False)</code>","text":"<p>Convert protocol to BattInfo JSON-LD format.</p> <p>This generates the 'hasTask' key in BattINFO, and does not include the creator, lab, instrument etc.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>Path | str | None</code> <p>(optional) File path of where to save the JSON-LD file.</p> <code>None</code> <code>capacity_mAh</code> <code>float | None</code> <p>(optional) Override the protocol sample capacity.</p> <code>None</code> <code>include_context</code> <code>bool</code> <p>(optional) Add a <code>@context</code> key to the root of the JSON-LD.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the JSON-LD.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>def to_battinfo_jsonld(\n    self,\n    save_path: Path | str | None = None,\n    capacity_mAh: float | None = None,\n    *,\n    include_context: bool = False,\n) -&gt; dict:\n    \"\"\"Convert protocol to BattInfo JSON-LD format.\n\n    This generates the 'hasTask' key in BattINFO, and does not include the\n    creator, lab, instrument etc.\n\n    Args:\n        save_path: (optional) File path of where to save the JSON-LD file.\n        capacity_mAh: (optional) Override the protocol sample capacity.\n        include_context: (optional) Add a `@context` key to the root of the\n            JSON-LD.\n\n    Returns:\n        Dictionary representation of the JSON-LD.\n\n    \"\"\"\n\n    def group_iterative_tasks(\n        step_numbers: list[int], method: Sequence[AnyTechnique]\n    ) -&gt; list[int | tuple[int, list]]:\n        \"\"\"Take a list of techniques, find the iterative loops.\n\n        Returns a list containing ints (a task) or a tuple of an int and\n        list (an iterative workflow).\n\n        E.g. [0,1,2,(1000, [4,5,6])]\n        Means do tasks 0, 1, 2, then loop over 4, 5, 6 1000 times.\n        \"\"\"\n        # Either this is surprisingly complex, or I am just stupid\n        # Assume there are no intersecting loops and tags are removed\n        # Must iterate BACKWARDS over techniques and treat loops recursively\n\n        tasks: list[int | tuple[int, list]] = []\n        skip_above: int | None = None\n\n        list_indices = list(range(len(method)))\n\n        for i, step_number in zip(reversed(list_indices), reversed(step_numbers), strict=True):\n            # If the techniques are already included in a loop at a higher depth, skip\n            if skip_above and step_numbers[i] &gt;= skip_above:\n                continue\n\n            # If the technique is a loop, the whole loop goes inside a tuple\n            if isinstance(method[i], Loop):\n                loop_object = method[i]\n                assert isinstance(loop_object, Loop)  # noqa: S101\n                assert isinstance(loop_object.loop_to, int)  # noqa: S101\n                cycle_count = loop_object.cycle_count\n                start_step: int = loop_object.loop_to - 1  # because loop_to is 1-indexed\n\n                # Find the subsection that the loop belongs to\n                start_i = next(j for j, n in enumerate(step_numbers) if n == start_step)\n                end_i = i\n\n                # Add this element, recursively run this function on the loops subsection\n                tasks.append(\n                    (\n                        cycle_count,\n                        group_iterative_tasks(\n                            step_numbers[start_i:end_i], method[start_i:end_i]\n                        ),\n                    ),\n                )\n\n                # Skip the rest of the loop at this depth\n                skip_above = start_step\n            else:\n                # Just add the technique\n                tasks.append(step_number)\n        return tasks[::-1]\n\n    def battinfoify_technique(step: AnyTechnique, capacity_mAh: float | None) -&gt; dict:\n        \"\"\"Create a single BattINFO dict from a technique.\"\"\"\n        match step:\n            case OpenCircuitVoltage():\n                tech_dict = {\n                    \"@type\": \"Resting\",\n                    \"hasInput\": [\n                        {\n                            \"@type\": \"Duration\",\n                            \"hasNumericalPart\": {\n                                \"@type\": \"RealData\",\n                                \"hasNumberValue\": step.until_time_s,\n                            },\n                            \"hasMeasurementUnit\": \"Second\",\n                        }\n                    ],\n                }\n            case ConstantCurrent():\n                inputs = []\n                current_mA: float | None = None\n                if step.rate_C and capacity_mAh:\n                    current_mA = step.rate_C * capacity_mAh\n                elif step.current_mA:\n                    current_mA = step.current_mA\n                charging = (current_mA and current_mA &gt; 0) or (step.rate_C and step.rate_C &gt; 0)\n                if current_mA:\n                    inputs.append(\n                        {\n                            \"@type\": \"ElectricCurrent\",\n                            \"hasNumericalPart\": {\n                                \"@type\": \"RealData\",\n                                \"hasNumberValue\": abs(current_mA),\n                            },\n                            \"hasMeasurementUnit\": \"MilliAmpere\",\n                        },\n                    )\n                if step.rate_C:\n                    inputs.append(\n                        {\n                            \"@type\": \"CRate\",\n                            \"hasNumericalPart\": {\n                                \"@type\": \"RealData\",\n                                \"hasNumberValue\": abs(step.rate_C),\n                            },\n                            \"hasMeasurementUnit\": \"CRateUnit\",\n                        },\n                    )\n                if step.until_voltage_V:\n                    inputs.append(\n                        {\n                            \"@type\": [\n                                \"UpperVoltageLimit\" if charging else \"LowerVoltageLimit\",\n                                \"TerminationQuantity\",\n                            ],\n                            \"hasNumericalPart\": {\n                                \"@type\": \"RealData\",\n                                \"hasNumberValue\": step.until_voltage_V,\n                            },\n                            \"hasMeasurementUnit\": \"Volt\",\n                        }\n                    )\n                if step.until_time_s:\n                    inputs.append(\n                        {\n                            \"@type\": \"Duration\",\n                            \"hasNumericalPart\": {\n                                \"@type\": \"RealData\",\n                                \"hasNumberValue\": step.until_time_s,\n                            },\n                            \"hasMeasurementUnit\": \"Second\",\n                        }\n                    )\n                tech_dict = {\n                    \"@type\": \"Charging\" if charging else \"Discharging\",\n                    \"hasInput\": inputs,\n                }\n            case ConstantVoltage():\n                inputs = [\n                    {\n                        \"@type\": \"Voltage\",\n                        \"hasNumericalPart\": {\n                            \"@type\": \"RealData\",\n                            \"hasNumberValue\": step.voltage_V,\n                        },\n                        \"hasMeasurementUnit\": \"Volt\",\n                    }\n                ]\n                until_current_mA: None | float = None\n                if step.until_rate_C and capacity_mAh:\n                    until_current_mA = step.until_rate_C * capacity_mAh\n                elif step.until_current_mA:\n                    until_current_mA = step.until_current_mA\n                if until_current_mA is not None:\n                    inputs.append(\n                        {\n                            \"@type\": [\"LowerCurrentLimit\", \"TerminationQuantity\"],\n                            \"hasNumericalPart\": {\n                                \"@type\": \"RealData\",\n                                \"hasNumberValue\": abs(until_current_mA),\n                            },\n                            \"hasMeasurementUnit\": \"MilliAmpere\",\n                        }\n                    )\n                if step.until_rate_C:\n                    inputs.append(\n                        {\n                            \"@type\": [\"LowerCRateLimit\", \"TerminationQuantity\"],\n                            \"hasNumericalPart\": {\n                                \"@type\": \"RealData\",\n                                \"hasNumberValue\": abs(step.until_rate_C),\n                            },\n                            \"hasMeasurementUnit\": \"CRateUnit\",\n                        },\n                    )\n                if step.until_time_s:\n                    inputs.append(\n                        {\n                            \"@type\": \"Duration\",\n                            \"hasNumericalPart\": {\n                                \"@type\": \"RealData\",\n                                \"hasNumberValue\": step.until_time_s,\n                            },\n                            \"hasMeasurementUnit\": \"Second\",\n                        }\n                    )\n                tech_dict = {\n                    \"@type\": \"Hold\",\n                    \"hasInput\": inputs,\n                }\n            case _:\n                msg = f\"Technique {step.step} not supported by to_battinfo_jsonld()\"\n                raise NotImplementedError(msg)\n        return tech_dict\n\n    def recursive_battinfo_build(\n        order: list[int | tuple[int, list]],\n        methods: Sequence[AnyTechnique],\n        capacity_mAh: float | None,\n    ) -&gt; dict:\n        \"\"\"Recursively build the a BattINFO JSON-LD from a method.\"\"\"\n        if isinstance(order[0], int):\n            # It is just a normal techqniue\n            this_tech = battinfoify_technique(methods[order[0]], capacity_mAh)\n        else:\n            # It is an iterative workflow\n            assert isinstance(order[0], tuple)  # noqa: S101\n            this_tech = {\n                \"@type\": \"IterativeWorkflow\",\n                \"hasInput\": [\n                    {\n                        \"@type\": \"NumberOfIterations\",\n                        \"hasNumericalPart\": {\n                            \"@type\": \"RealData\",\n                            \"hasNumberValue\": order[0][0],\n                        },\n                        \"hasMeasurementUnit\": \"UnitOne\",\n                    }\n                ],\n                \"hasTask\": recursive_battinfo_build(order[0][1], methods, capacity_mAh),\n            }\n\n        # If there is another technique, keep going\n        if len(order) &gt; 1:\n            this_tech[\"hasNext\"] = recursive_battinfo_build(order[1:], methods, capacity_mAh)\n        return this_tech\n\n    # Create and operate on a copy of the original object\n    protocol = self.model_copy()\n\n    # Allow overwriting capacity\n    if capacity_mAh:\n        protocol.sample.capacity_mAh = capacity_mAh\n\n    # Make sure there are no tags or interecting loops\n    protocol._tag_to_indices()\n    protocol._check_for_intersecting_loops()\n\n    # Get the order of techniques with nested loops\n    battinfo_order = group_iterative_tasks(list(range(len(protocol.method))), protocol.method)\n\n    # Build the battinfo JSON-LD\n    battinfo_dict = recursive_battinfo_build(\n        battinfo_order, protocol.method, protocol.sample.capacity_mAh\n    )\n\n    # Include context at this level, if requested\n    if include_context:\n        battinfo_dict[\"@context\"] = [\n            \"https://w3id.org/emmo/domain/battery/context\",\n        ]\n\n    # Optionally save\n    if save_path:\n        save_path = Path(save_path)\n        save_path.parent.mkdir(parents=True, exist_ok=True)\n        with save_path.open(\"w\", encoding=\"utf-8\") as f:\n            json.dump(battinfo_dict, f, indent=4)\n\n    return battinfo_dict\n</code></pre>"},{"location":"api/#aurora_unicycler.Protocol.to_biologic_mps","title":"<code>to_biologic_mps(save_path=None, sample_name=None, capacity_mAh=None)</code>","text":"<p>Convert protocol to a Biologic Settings file (.mps).</p> <p>Uses the ModuloBatt technique.</p> <p>Note that you must add OCV steps inbetween CC/CV steps if you want the current range to be able to change.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>Path | str | None</code> <p>(optional) File path of where to save the mps file.</p> <code>None</code> <code>sample_name</code> <code>str | None</code> <p>(optional) Override the protocol sample name.</p> <code>None</code> <code>capacity_mAh</code> <code>float | None</code> <p>(optional) Override the protocol sample capacity.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>mps string representation of the protocol.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>def to_biologic_mps(\n    self,\n    save_path: Path | str | None = None,\n    sample_name: str | None = None,\n    capacity_mAh: float | None = None,\n) -&gt; str:\n    \"\"\"Convert protocol to a Biologic Settings file (.mps).\n\n    Uses the ModuloBatt technique.\n\n    Note that you must add OCV steps inbetween CC/CV steps if you want the\n    current range to be able to change.\n\n    Args:\n        save_path: (optional) File path of where to save the mps file.\n        sample_name: (optional) Override the protocol sample name.\n        capacity_mAh: (optional) Override the protocol sample capacity.\n\n    Returns:\n        mps string representation of the protocol.\n\n    \"\"\"\n    # Create and operate on a copy of the original object\n    protocol = self.model_copy()\n\n    # Allow overwriting name and capacity\n    if sample_name:\n        protocol.sample.name = sample_name\n    if capacity_mAh:\n        protocol.sample.capacity_mAh = capacity_mAh\n\n    # Make sure sample name is set\n    if not protocol.sample.name or protocol.sample.name == \"$NAME\":\n        msg = (\n            \"If using blank sample name or $NAME placeholder, \"\n            \"a sample name must be provided in this function.\"\n        )\n        raise ValueError(msg)\n\n    # Make sure capacity is set if using C-rate steps\n    protocol._validate_capacity_c_rates()\n\n    # Remove tags and convert to indices\n    protocol._tag_to_indices()\n    protocol._check_for_intersecting_loops()\n\n    header = [\n        \"EC-LAB SETTING FILE\",\n        \"\",\n        \"Number of linked techniques : 1\",\n        \"Device : MPG-2\",\n        \"CE vs. WE compliance from -10 V to 10 V\",\n        \"Electrode connection : standard\",\n        \"Potential control : Ewe\",\n        \"Ewe ctrl range : min = 0.00 V, max = 5.00 V\",\n        \"Safety Limits :\",\n        \"\tDo not start on E overload\",\n        f\"Comments : {protocol.sample.name}\",\n        \"Cycle Definition : Charge/Discharge alternance\",\n        \"Do not turn to OCV between techniques\",\n        \"\",\n        \"Technique : 1\",\n        \"Modulo Bat\",\n    ]\n\n    default_step = {\n        \"Ns\": \"\",\n        \"ctrl_type\": \"\",\n        \"Apply I/C\": \"I\",\n        \"current/potential\": \"current\",\n        \"ctrl1_val\": \"\",\n        \"ctrl1_val_unit\": \"\",\n        \"ctrl1_val_vs\": \"\",\n        \"ctrl2_val\": \"\",\n        \"ctrl2_val_unit\": \"\",\n        \"ctrl2_val_vs\": \"\",\n        \"ctrl3_val\": \"\",\n        \"ctrl3_val_unit\": \"\",\n        \"ctrl3_val_vs\": \"\",\n        \"N\": \"0.00\",\n        \"charge/discharge\": \"Charge\",\n        \"charge/discharge_1\": \"Charge\",\n        \"Apply I/C_1\": \"I\",\n        \"N1\": \"0.00\",\n        \"ctrl4_val\": \"\",\n        \"ctrl4_val_unit\": \"\",\n        \"ctrl5_val\": \"\",\n        \"ctrl5_val_unit\": \"\",\n        \"ctrl_tM\": \"0\",\n        \"ctrl_seq\": \"0\",\n        \"ctrl_repeat\": \"0\",\n        \"ctrl_trigger\": \"Falling Edge\",\n        \"ctrl_TO_t\": \"0.000\",\n        \"ctrl_TO_t_unit\": \"d\",\n        \"ctrl_Nd\": \"6\",\n        \"ctrl_Na\": \"2\",\n        \"ctrl_corr\": \"0\",\n        \"lim_nb\": \"0\",\n        \"lim1_type\": \"Time\",\n        \"lim1_comp\": \"&gt;\",\n        \"lim1_Q\": \"\",\n        \"lim1_value\": \"0.000\",\n        \"lim1_value_unit\": \"s\",\n        \"lim1_action\": \"Next sequence\",\n        \"lim1_seq\": \"\",\n        \"lim2_type\": \"\",\n        \"lim2_comp\": \"\",\n        \"lim2_Q\": \"\",\n        \"lim2_value\": \"\",\n        \"lim2_value_unit\": \"\",\n        \"lim2_action\": \"Next sequence\",\n        \"lim2_seq\": \"\",\n        \"rec_nb\": \"0\",\n        \"rec1_type\": \"\",\n        \"rec1_value\": \"\",\n        \"rec1_value_unit\": \"\",\n        \"rec2_type\": \"\",\n        \"rec2_value\": \"\",\n        \"rec2_value_unit\": \"\",\n        \"E range min (V)\": \"0.000\",\n        \"E range max (V)\": \"5.000\",\n        \"I Range\": \"Auto\",\n        \"I Range min\": \"Unset\",\n        \"I Range max\": \"Unset\",\n        \"I Range init\": \"Unset\",\n        \"auto rest\": \"1\",\n        \"Bandwidth\": \"5\",\n    }\n\n    # Use fixed I range for CC and GEIS steps, Auto otherwise\n    # There is no Auto option for CC or GEIS\n    I_ranges_mA = {\n        0.01: \"10 \u00b5A\",\n        0.1: \"100 \u00b5A\",\n        1: \"1 mA\",\n        10: \"10 mA\",\n        100: \"100 mA\",\n    }\n\n    # Make a list of dicts, one for each step\n    step_dicts = []\n    for i, step in enumerate(protocol.method):\n        step_dict = default_step.copy()\n        step_dict.update(\n            {\n                \"Ns\": str(i),\n                \"lim1_seq\": str(i + 1),\n                \"lim2_seq\": str(i + 1),\n            },\n        )\n        match step:\n            case OpenCircuitVoltage():\n                step_dict.update(\n                    {\n                        \"ctrl_type\": \"Rest\",\n                        \"lim_nb\": \"1\",\n                        \"lim1_type\": \"Time\",\n                        \"lim1_comp\": \"&gt;\",\n                        \"lim1_value\": f\"{step.until_time_s:.3f}\",\n                        \"lim1_value_unit\": \"s\",\n                        \"rec_nb\": \"1\",\n                        \"rec1_type\": \"Time\",\n                        \"rec1_value\": f\"{protocol.record.time_s or 0:.3f}\",\n                        \"rec1_value_unit\": \"s\",\n                    },\n                )\n\n            case ConstantCurrent():\n                if step.rate_C and protocol.sample.capacity_mAh:\n                    current_mA = step.rate_C * protocol.sample.capacity_mAh\n                elif step.current_mA:\n                    current_mA = step.current_mA\n                else:\n                    msg = \"Either rate_C or current_mA must be set for ConstantCurrent step.\"\n                    raise ValueError(msg)\n\n                if abs(current_mA) &lt; 1:\n                    step_dict.update(\n                        {\n                            \"ctrl_type\": \"CC\",\n                            \"ctrl1_val\": f\"{current_mA * 1e3:.3f}\",\n                            \"ctrl1_val_unit\": \"uA\",\n                            \"ctrl1_val_vs\": \"&lt;None&gt;\",\n                        },\n                    )\n                else:\n                    step_dict.update(\n                        {\n                            \"ctrl_type\": \"CC\",\n                            \"ctrl1_val\": f\"{current_mA:.3f}\",\n                            \"ctrl1_val_unit\": \"mA\",\n                            \"ctrl1_val_vs\": \"&lt;None&gt;\",\n                        },\n                    )\n                for val, range_str in I_ranges_mA.items():\n                    if abs(current_mA) &lt;= val:\n                        step_dict.update({\"I Range\": range_str})\n                        break\n                else:\n                    msg = f\"I range not supported for {current_mA} mA\"\n                    raise ValueError(msg)\n\n                # Add limit details\n                lim_num = 0\n                if step.until_time_s:\n                    lim_num += 1\n                    step_dict.update(\n                        {\n                            f\"lim{lim_num}_type\": \"Time\",\n                            f\"lim{lim_num}_comp\": \"&gt;\",\n                            f\"lim{lim_num}_value\": f\"{step.until_time_s:.3f}\",\n                            f\"lim{lim_num}_value_unit\": \"s\",\n                        },\n                    )\n                if step.until_voltage_V:\n                    lim_num += 1\n                    comp = \"&gt;\" if current_mA &gt; 0 else \"&lt;\"\n                    step_dict.update(\n                        {\n                            f\"lim{lim_num}_type\": \"Ewe\",\n                            f\"lim{lim_num}_comp\": comp,\n                            f\"lim{lim_num}_value\": f\"{step.until_voltage_V:.3f}\",\n                            f\"lim{lim_num}_value_unit\": \"V\",\n                        },\n                    )\n                step_dict.update(\n                    {\n                        \"lim_nb\": str(lim_num),\n                    },\n                )\n\n                # Add record details\n                rec_num = 0\n                if protocol.record.time_s:\n                    rec_num += 1\n                    step_dict.update(\n                        {\n                            f\"rec{rec_num}_type\": \"Time\",\n                            f\"rec{rec_num}_value\": f\"{protocol.record.time_s:.3f}\",\n                            f\"rec{rec_num}_value_unit\": \"s\",\n                        },\n                    )\n                if protocol.record.voltage_V:\n                    rec_num += 1\n                    step_dict.update(\n                        {\n                            f\"rec{rec_num}_type\": \"Ewe\",\n                            f\"rec{rec_num}_value\": f\"{protocol.record.voltage_V:.3f}\",\n                            f\"rec{rec_num}_value_unit\": \"V\",\n                        },\n                    )\n                step_dict.update(\n                    {\n                        \"rec_nb\": str(rec_num),\n                    },\n                )\n\n            case ConstantVoltage():\n                step_dict.update(\n                    {\n                        \"ctrl_type\": \"CV\",\n                        \"ctrl1_val\": f\"{step.voltage_V:.3f}\",\n                        \"ctrl1_val_unit\": \"V\",\n                        \"ctrl1_val_vs\": \"Ref\",\n                    },\n                )\n\n                # Add limit details\n                lim_num = 0\n                if step.until_time_s:\n                    lim_num += 1\n                    step_dict.update(\n                        {\n                            f\"lim{lim_num}_type\": \"Time\",\n                            f\"lim{lim_num}_comp\": \"&gt;\",\n                            f\"lim{lim_num}_value\": f\"{step.until_time_s:.3f}\",\n                            f\"lim{lim_num}_value_unit\": \"s\",\n                        },\n                    )\n                if step.until_rate_C and protocol.sample.capacity_mAh:\n                    until_mA = step.until_rate_C * protocol.sample.capacity_mAh\n                elif step.until_current_mA:\n                    until_mA = step.until_current_mA\n                else:\n                    until_mA = None\n                if until_mA:\n                    lim_num += 1\n                    step_dict.update(\n                        {\n                            f\"lim{lim_num}_type\": \"|I|\",\n                            f\"lim{lim_num}_comp\": \"&lt;\",\n                            f\"lim{lim_num}_value\": f\"{abs(until_mA):.3f}\",\n                            f\"lim{lim_num}_value_unit\": \"mA\",\n                        },\n                    )\n                step_dict.update(\n                    {\n                        \"lim_nb\": str(lim_num),\n                    },\n                )\n                if i &gt; 0:\n                    prev_mA = None\n                    prev_step = protocol.method[i - 1]\n                    if isinstance(prev_step, ConstantCurrent):\n                        prev_mA = None\n                        if prev_step.rate_C and protocol.sample.capacity_mAh:\n                            prev_mA = prev_step.rate_C * protocol.sample.capacity_mAh\n                        elif prev_step.current_mA:\n                            prev_mA = prev_step.current_mA\n                        if prev_mA and prev_step.until_voltage_V == step.voltage_V:\n                            for val, range_str in I_ranges_mA.items():\n                                if abs(prev_mA) &lt;= val:\n                                    step_dict.update({\"I Range\": range_str})\n                                    break\n\n                # Add record details\n                rec_num = 0\n                if protocol.record.time_s:\n                    rec_num += 1\n                    step_dict.update(\n                        {\n                            f\"rec{rec_num}_type\": \"Time\",\n                            f\"rec{rec_num}_value\": f\"{protocol.record.time_s:.3f}\",\n                            f\"rec{rec_num}_value_unit\": \"s\",\n                        },\n                    )\n                if protocol.record.current_mA:\n                    rec_num += 1\n                    step_dict.update(\n                        {\n                            f\"rec{rec_num}_type\": \"I\",\n                            f\"rec{rec_num}_value\": f\"{protocol.record.current_mA:.3f}\",\n                            f\"rec{rec_num}_value_unit\": \"mA\",\n                        },\n                    )\n                step_dict.update(\n                    {\n                        \"rec_nb\": str(rec_num),\n                    },\n                )\n\n            case ImpedanceSpectroscopy():\n                if step.amplitude_V:\n                    step_dict.update({\"ctrl_type\": \"PEIS\"})\n                    if step.amplitude_V &gt;= 0.1:\n                        step_dict.update({\"ctrl1_val\": f\"{step.amplitude_V:.3f}\"})\n                        step_dict.update({\"ctrl1_val_unit\": \"V\"})\n                    elif step.amplitude_V &gt;= 0.001:\n                        step_dict.update({\"ctrl1_val\": f\"{step.amplitude_V * 1e3:.3f}\"})\n                        step_dict.update({\"ctrl1_val_unit\": \"mV\"})\n                    else:\n                        step_dict.update({\"ctrl1_val\": f\"{step.amplitude_V * 1e6:.3f}\"})\n                        step_dict.update({\"ctrl1_val_unit\": \"uV\"})\n\n                elif step.amplitude_mA:\n                    step_dict.update({\"ctrl_type\": \"GEIS\"})\n                    if step.amplitude_mA &gt;= 1000:\n                        step_dict.update({\"ctrl1_val\": f\"{step.amplitude_mA / 1000:.3f}\"})\n                        step_dict.update({\"ctrl1_val_unit\": \"A\"})\n                    elif step.amplitude_mA &gt;= 1:\n                        step_dict.update({\"ctrl1_val\": f\"{step.amplitude_mA:.3f}\"})\n                        step_dict.update({\"ctrl1_val_unit\": \"mA\"})\n                    else:\n                        step_dict.update({\"ctrl1_val\": f\"{step.amplitude_mA * 1000:.3f}\"})\n                        step_dict.update({\"ctrl1_val_unit\": \"uA\"})\n\n                    for val, range_str in I_ranges_mA.items():\n                        # GEIS I range behaves differently to CC\n                        # 1 mA range means 0.5 mA max amplitude\n                        if abs(step.amplitude_mA) * 2 &lt;= val:\n                            step_dict.update({\"I Range\": range_str})\n                            break\n                    else:\n                        msg = f\"I range not supported for {step.amplitude_mA} mA\"\n                        raise ValueError(msg)\n\n                else:\n                    msg = \"Either amplitude_V or amplitude_mA must be set.\"\n                    raise ValueError(msg)\n\n                for freq, ctrl in ((step.start_frequency_Hz, 2), (step.end_frequency_Hz, 3)):\n                    if freq &gt;= 1e3:\n                        step_dict.update({f\"ctrl{ctrl}_val\": f\"{freq / 1e3:.3f}\"})\n                        step_dict.update({f\"ctrl{ctrl}_val_unit\": \"kHz\"})\n                    elif freq &gt;= 1:\n                        step_dict.update({f\"ctrl{ctrl}_val\": f\"{freq:.3f}\"})\n                        step_dict.update({f\"ctrl{ctrl}_val_unit\": \"Hz\"})\n                    elif freq &gt;= 1e-3:\n                        step_dict.update({f\"ctrl{ctrl}_val\": f\"{freq * 1e3:.3f}\"})\n                        step_dict.update({f\"ctrl{ctrl}_val_unit\": \"mHz\"})\n                step_dict.update(\n                    {\n                        \"ctrl_Nd\": f\"{step.points_per_decade}\",\n                        \"ctrl_Na\": f\"{step.measures_per_point}\",\n                        \"ctrl_corr\": f\"{1 if step.drift_correction is True else 0}\",\n                    }\n                )\n\n            case Loop():\n                assert isinstance(step.loop_to, int)  # noqa: S101, from _tag_to_indices()\n                step_dict.update(\n                    {\n                        \"ctrl_type\": \"Loop\",\n                        \"ctrl_seq\": str(step.loop_to - 1),  # 0-indexed here\n                        \"ctrl_repeat\": str(\n                            step.cycle_count - 1\n                        ),  # cycles is one less than n_gotos\n                    },\n                )\n\n            case _:\n                msg = f\"to_biologic_mps() does not support step type: {step.step}\"\n                raise NotImplementedError(msg)\n\n        step_dicts.append(step_dict)\n\n    # Transform list of dicts into list of strings\n    # Each row is one key and all values of each step\n    # All elements must be 20 characters wide\n    rows = []\n    for row_header in default_step:\n        row_data = [step[row_header] for step in step_dicts]\n        rows.append(row_header.ljust(20) + \"\".join(d.ljust(20) for d in row_data))\n\n    settings_string = \"\\n\".join([*header, *rows, \"\"])\n\n    if save_path:\n        save_path = Path(save_path)\n        save_path.parent.mkdir(parents=True, exist_ok=True)\n        with save_path.open(\"w\", encoding=\"cp1252\") as f:\n            f.write(settings_string)\n\n    return settings_string\n</code></pre>"},{"location":"api/#aurora_unicycler.Protocol.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert a Protocol instance to a dictionary.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert a Protocol instance to a dictionary.\"\"\"\n    return self.model_dump()\n</code></pre>"},{"location":"api/#aurora_unicycler.Protocol.to_json","title":"<code>to_json(json_file=None, indent=4)</code>","text":"<p>Dump model as JSON string, optionally save as a JSON file.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>def to_json(self, json_file: str | Path | None = None, indent: int = 4) -&gt; str:\n    \"\"\"Dump model as JSON string, optionally save as a JSON file.\"\"\"\n    json_string = self.model_dump_json(indent=indent)\n    if json_file:\n        json_file = Path(json_file)\n        json_file.parent.mkdir(parents=True, exist_ok=True)\n        with json_file.open(\"w\", encoding=\"utf-8\") as f:\n            f.write(json_string)\n    return json_string\n</code></pre>"},{"location":"api/#aurora_unicycler.Protocol.to_neware_xml","title":"<code>to_neware_xml(save_path=None, sample_name=None, capacity_mAh=None)</code>","text":"<p>Convert the protocol to Neware XML format.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>Path | str | None</code> <p>(optional) File path of where to save the xml file.</p> <code>None</code> <code>sample_name</code> <code>str | None</code> <p>(optional) Override the protocol sample name. A sample name must be provided in this function. It is stored as the 'barcode' of the Neware protocol.</p> <code>None</code> <code>capacity_mAh</code> <code>float | None</code> <p>(optional) Override the protocol sample capacity.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>xml string representation of the protocol.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>def to_neware_xml(\n    self,\n    save_path: Path | str | None = None,\n    sample_name: str | None = None,\n    capacity_mAh: float | None = None,\n) -&gt; str:\n    \"\"\"Convert the protocol to Neware XML format.\n\n    Args:\n        save_path: (optional) File path of where to save the xml file.\n        sample_name: (optional) Override the protocol sample name. A sample\n            name must be provided in this function. It is stored as the\n            'barcode' of the Neware protocol.\n        capacity_mAh: (optional) Override the protocol sample capacity.\n\n    Returns:\n        xml string representation of the protocol.\n\n    \"\"\"\n    # Create and operate on a copy of the original object\n    protocol = self.model_copy()\n\n    # Allow overwriting name and capacity\n    if sample_name:\n        protocol.sample.name = sample_name\n    if capacity_mAh:\n        protocol.sample.capacity_mAh = capacity_mAh\n\n    # Make sure sample name is set\n    if not protocol.sample.name or protocol.sample.name == \"$NAME\":\n        msg = (\n            \"If using blank sample name or $NAME placeholder, \"\n            \"a sample name must be provided in this function.\"\n        )\n        raise ValueError(msg)\n\n    # Make sure capacity is set if using C-rate steps\n    protocol._validate_capacity_c_rates()\n\n    # Remove tags and convert to indices\n    protocol._tag_to_indices()\n    protocol._check_for_intersecting_loops()\n\n    # Create XML structure\n    root = ET.Element(\"root\")\n    config = ET.SubElement(\n        root,\n        \"config\",\n        type=\"Step File\",\n        version=\"17\",\n        client_version=\"BTS Client 8.0.0.478(2024.06.24)(R3)\",\n        date=datetime.now().strftime(\"%Y%m%d%H%M%S\"),\n        Guid=str(uuid.uuid4()),\n    )\n    head_info = ET.SubElement(config, \"Head_Info\")\n    ET.SubElement(head_info, \"Operate\", Value=\"66\")\n    ET.SubElement(head_info, \"Scale\", Value=\"1\")\n    ET.SubElement(head_info, \"Start_Step\", Value=\"1\", Hide_Ctrl_Step=\"0\")\n    ET.SubElement(head_info, \"Creator\", Value=\"aurora-unicycler\")\n    ET.SubElement(head_info, \"Remark\", Value=protocol.sample.name)\n    # 103, non C-rate mode, seems to give more precise values vs 105\n    ET.SubElement(head_info, \"RateType\", Value=\"103\")\n    if protocol.sample.capacity_mAh:\n        ET.SubElement(head_info, \"MultCap\", Value=f\"{protocol.sample.capacity_mAh * 3600:f}\")\n\n    whole_prt = ET.SubElement(config, \"Whole_Prt\")\n    protect = ET.SubElement(whole_prt, \"Protect\")\n    main_protect = ET.SubElement(protect, \"Main\")\n    volt = ET.SubElement(main_protect, \"Volt\")\n    if protocol.safety.max_voltage_V:\n        ET.SubElement(volt, \"Upper\", Value=f\"{protocol.safety.max_voltage_V * 10000:f}\")\n    if protocol.safety.min_voltage_V:\n        ET.SubElement(volt, \"Lower\", Value=f\"{protocol.safety.min_voltage_V * 10000:f}\")\n    curr = ET.SubElement(main_protect, \"Curr\")\n    if protocol.safety.max_current_mA:\n        ET.SubElement(curr, \"Upper\", Value=f\"{protocol.safety.max_current_mA:f}\")\n    if protocol.safety.min_current_mA:\n        ET.SubElement(curr, \"Lower\", Value=f\"{protocol.safety.min_current_mA:f}\")\n    if protocol.safety.delay_s:\n        ET.SubElement(main_protect, \"Delay_Time\", Value=f\"{protocol.safety.delay_s * 1000:f}\")\n    cap = ET.SubElement(main_protect, \"Cap\")\n    if protocol.safety.max_capacity_mAh:\n        ET.SubElement(cap, \"Upper\", Value=f\"{protocol.safety.max_capacity_mAh * 3600:f}\")\n\n    record = ET.SubElement(whole_prt, \"Record\")\n    main_record = ET.SubElement(record, \"Main\")\n    if protocol.record.time_s:\n        ET.SubElement(main_record, \"Time\", Value=f\"{protocol.record.time_s * 1000:f}\")\n    if protocol.record.voltage_V:\n        ET.SubElement(main_record, \"Volt\", Value=f\"{protocol.record.voltage_V * 10000:f}\")\n    if protocol.record.current_mA:\n        ET.SubElement(main_record, \"Curr\", Value=f\"{protocol.record.current_mA:f}\")\n\n    step_info = ET.SubElement(\n        config, \"Step_Info\", Num=str(len(protocol.method) + 1)\n    )  # +1 for end step\n\n    def _step_to_element(\n        step: AnyTechnique,\n        step_num: int,\n        parent: ET.Element,\n        prev_step: AnyTechnique | None = None,\n    ) -&gt; None:\n        \"\"\"Create XML subelement from protocol technique.\"\"\"\n        match step:\n            case ConstantCurrent():\n                if step.rate_C is not None and step.rate_C != 0:\n                    step_type = \"1\" if step.rate_C &gt; 0 else \"2\"\n                elif step.current_mA is not None and step.current_mA != 0:\n                    step_type = \"1\" if step.current_mA &gt; 0 else \"2\"\n                else:\n                    msg = \"Must have a current or C-rate\"\n                    raise ValueError(msg)\n\n                step_element = ET.SubElement(\n                    parent, f\"Step{step_num}\", Step_ID=str(step_num), Step_Type=step_type\n                )\n                limit = ET.SubElement(step_element, \"Limit\")\n                main = ET.SubElement(limit, \"Main\")\n                if step.rate_C is not None:\n                    assert protocol.sample.capacity_mAh is not None  # noqa: S101, from _validate_capacity_c_rates()\n                    ET.SubElement(main, \"Rate\", Value=f\"{abs(step.rate_C):f}\")\n                    ET.SubElement(\n                        main,\n                        \"Curr\",\n                        Value=f\"{abs(step.rate_C) * protocol.sample.capacity_mAh:f}\",\n                    )\n                elif step.current_mA is not None:\n                    ET.SubElement(main, \"Curr\", Value=f\"{abs(step.current_mA):f}\")\n                if step.until_time_s is not None:\n                    ET.SubElement(main, \"Time\", Value=f\"{step.until_time_s * 1000:f}\")\n                if step.until_voltage_V is not None:\n                    ET.SubElement(main, \"Stop_Volt\", Value=f\"{step.until_voltage_V * 10000:f}\")\n\n            case ConstantVoltage():\n                # Check if CV follows CC and has the same voltage cutoff\n                prev_rate_C = None\n                prev_current_mA = None\n                if (\n                    isinstance(prev_step, ConstantCurrent)\n                    and prev_step.until_voltage_V == step.voltage_V\n                ):\n                    if prev_step.rate_C is not None:\n                        assert protocol.sample.capacity_mAh is not None  # noqa: S101, from _validate_capacity_c_rates()\n                        prev_rate_C = abs(prev_step.rate_C)\n                        prev_current_mA = abs(prev_step.rate_C) * protocol.sample.capacity_mAh\n                    elif prev_step.current_mA is not None:\n                        prev_current_mA = abs(prev_step.current_mA)\n                if step.until_rate_C is not None and step.until_rate_C != 0:\n                    step_type = \"3\" if step.until_rate_C &gt; 0 else \"19\"\n                elif step.until_current_mA is not None and step.until_current_mA != 0:\n                    step_type = \"3\" if step.until_current_mA &gt; 0 else \"19\"\n                else:\n                    step_type = \"3\"  # If it can't be figured out, default to charge\n                step_element = ET.SubElement(\n                    parent, f\"Step{step_num}\", Step_ID=str(step_num), Step_Type=step_type\n                )\n                limit = ET.SubElement(step_element, \"Limit\")\n                main = ET.SubElement(limit, \"Main\")\n                ET.SubElement(main, \"Volt\", Value=f\"{step.voltage_V * 10000:f}\")\n                if step.until_time_s is not None:\n                    ET.SubElement(main, \"Time\", Value=f\"{step.until_time_s * 1000:f}\")\n                if step.until_rate_C is not None:\n                    assert protocol.sample.capacity_mAh is not None  # noqa: S101, from _validate_capacity_c_rates()\n                    ET.SubElement(main, \"Stop_Rate\", Value=f\"{abs(step.until_rate_C):f}\")\n                    ET.SubElement(\n                        main,\n                        \"Stop_Curr\",\n                        Value=f\"{abs(step.until_rate_C) * protocol.sample.capacity_mAh:f}\",\n                    )\n                elif step.until_current_mA is not None:\n                    ET.SubElement(main, \"Stop_Curr\", Value=f\"{abs(step.until_current_mA):f}\")\n                if prev_rate_C is not None:\n                    assert protocol.sample.capacity_mAh is not None  # noqa: S101, from _validate_capacity_c_rates()\n                    ET.SubElement(main, \"Rate\", Value=f\"{abs(prev_rate_C):f}\")\n                    ET.SubElement(\n                        main,\n                        \"Curr\",\n                        Value=f\"{abs(prev_rate_C) * protocol.sample.capacity_mAh:f}\",\n                    )\n                elif prev_current_mA is not None:\n                    ET.SubElement(main, \"Curr\", Value=f\"{abs(prev_current_mA):f}\")\n\n            case OpenCircuitVoltage():\n                step_element = ET.SubElement(\n                    parent, f\"Step{step_num}\", Step_ID=str(step_num), Step_Type=\"4\"\n                )\n                limit = ET.SubElement(step_element, \"Limit\")\n                main = ET.SubElement(limit, \"Main\")\n                ET.SubElement(main, \"Time\", Value=f\"{step.until_time_s * 1000:f}\")\n\n            case Loop():\n                step_element = ET.SubElement(\n                    parent, f\"Step{step_num}\", Step_ID=str(step_num), Step_Type=\"5\"\n                )\n                limit = ET.SubElement(step_element, \"Limit\")\n                other = ET.SubElement(limit, \"Other\")\n                ET.SubElement(other, \"Start_Step\", Value=str(step.loop_to))\n                ET.SubElement(other, \"Cycle_Count\", Value=str(step.cycle_count))\n\n            case _:\n                msg = f\"to_neware_xml does not support step type: {step.step}\"\n                raise TypeError(msg)\n\n    for i, technique in enumerate(protocol.method):\n        step_num = i + 1\n        prev_step = protocol.method[i - 1] if i &gt;= 1 else None\n        _step_to_element(technique, step_num, step_info, prev_step)\n\n    # Add an end step\n    step_num = len(protocol.method) + 1\n    ET.SubElement(step_info, f\"Step{step_num}\", Step_ID=str(step_num), Step_Type=\"6\")\n\n    smbus = ET.SubElement(config, \"SMBUS\")\n    ET.SubElement(smbus, \"SMBUS_Info\", Num=\"0\", AdjacentInterval=\"0\")\n\n    # Convert to string and prettify it\n    pretty_xml_string = minidom.parseString(ET.tostring(root)).toprettyxml(indent=\"  \")  # noqa: S318\n    if save_path:\n        save_path = Path(save_path)\n        save_path.parent.mkdir(parents=True, exist_ok=True)\n        with save_path.open(\"w\", encoding=\"utf-8\") as f:\n            f.write(pretty_xml_string)\n    return pretty_xml_string\n</code></pre>"},{"location":"api/#aurora_unicycler.Protocol.to_pybamm_experiment","title":"<code>to_pybamm_experiment()</code>","text":"<p>Convert protocol to PyBaMM experiment format.</p> <p>A PyBaMM experiment does not need capacity or sample name.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list of strings representing the PyBaMM experiment.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>def to_pybamm_experiment(self) -&gt; list[str]:\n    \"\"\"Convert protocol to PyBaMM experiment format.\n\n    A PyBaMM experiment does not need capacity or sample name.\n\n    Returns:\n        list of strings representing the PyBaMM experiment.\n\n    \"\"\"\n    # Don't need to validate capacity if using C-rate steps\n    # Create and operate on a copy of the original object\n    protocol = self.model_copy()\n\n    # Remove tags and convert to indices\n    protocol._tag_to_indices()\n    protocol._check_for_intersecting_loops()\n\n    pybamm_experiment: list[str] = []\n    loops: dict[int, dict] = {}\n    for i, step in enumerate(protocol.method):\n        step_str = \"\"\n        match step:\n            case ConstantCurrent():\n                if step.rate_C:\n                    if step.rate_C &gt; 0:\n                        step_str += f\"Charge at {step.rate_C}C\"\n                    else:\n                        step_str += f\"Discharge at {abs(step.rate_C)}C\"\n                elif step.current_mA:\n                    if step.current_mA &gt; 0:\n                        step_str += f\"Charge at {step.current_mA} mA\"\n                    else:\n                        step_str += f\"Discharge at {abs(step.current_mA)} mA\"\n                if step.until_time_s:\n                    if step.until_time_s % 3600 == 0:\n                        step_str += f\" for {int(step.until_time_s / 3600)} hours\"\n                    elif step.until_time_s % 60 == 0:\n                        step_str += f\" for {int(step.until_time_s / 60)} minutes\"\n                    else:\n                        step_str += f\" for {step.until_time_s} seconds\"\n                if step.until_voltage_V:\n                    step_str += f\" until {step.until_voltage_V} V\"\n\n            case ConstantVoltage():\n                step_str += f\"Hold at {step.voltage_V} V\"\n                conditions = []\n                if step.until_time_s:\n                    if step.until_time_s % 3600 == 0:\n                        step_str += f\" for {int(step.until_time_s / 3600)} hours\"\n                    elif step.until_time_s % 60 == 0:\n                        step_str += f\" for {int(step.until_time_s / 60)} minutes\"\n                    else:\n                        conditions.append(f\"for {step.until_time_s} seconds\")\n                if step.until_rate_C:\n                    conditions.append(f\"until {step.until_rate_C}C\")\n                if step.until_current_mA:\n                    conditions.append(f\" until {step.until_current_mA} mA\")\n                if conditions:\n                    step_str += \" \" + \" or \".join(conditions)\n\n            case OpenCircuitVoltage():\n                step_str += f\"Rest for {step.until_time_s} seconds\"\n\n            case Loop():\n                # The string from this will get dropped later\n                assert isinstance(step.loop_to, int)  # noqa: S101, from _tag_to_indices()\n                loops[i] = {\"goto\": step.loop_to - 1, \"n\": step.cycle_count, \"n_done\": 0}\n\n            case _:\n                msg = f\"to_pybamm_experiment does not support step type: {step.step}\"\n                raise TypeError(msg)\n\n        pybamm_experiment.append(step_str)\n\n    exploded_steps = []\n    i = 0\n    total_itr = 0\n    while i &lt; len(pybamm_experiment):\n        exploded_steps.append(i)\n        if i in loops and loops[i][\"n_done\"] &lt; loops[i][\"n\"]:\n            # check if it passes over a different loop, if so reset its count\n            for j in loops:  # noqa: PLC0206\n                if j &lt; i and j &gt;= loops[i][\"goto\"]:\n                    loops[j][\"n_done\"] = 0\n            loops[i][\"n_done\"] += 1\n            i = loops[i][\"goto\"]\n        else:\n            i += 1\n        total_itr += 1\n        if total_itr &gt; 10000:\n            msg = (\n                \"Over 10000 steps in protocol to_pybamm_experiment(), \"\n                \"likely a loop definition error.\"\n            )\n            raise RuntimeError(msg)\n\n    # remove all loop steps from the list\n    cleaned_exploded_steps = [i for i in exploded_steps if i not in loops]\n    # change from list of indices to list of strings\n    return [pybamm_experiment[i] for i in cleaned_exploded_steps]\n</code></pre>"},{"location":"api/#aurora_unicycler.Protocol.to_tomato_mpg2","title":"<code>to_tomato_mpg2(save_path=None, tomato_output=Path('C:/tomato_data/'), sample_name=None, capacity_mAh=None)</code>","text":"<p>Convert protocol to tomato 0.2.3 + MPG2 compatible JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>Path | str | None</code> <p>(optional) File path of where to save the json file.</p> <code>None</code> <code>tomato_output</code> <code>Path</code> <p>(optional) Where to save the data from tomato.</p> <code>Path('C:/tomato_data/')</code> <code>sample_name</code> <code>str | None</code> <p>(optional) Override the protocol sample name.</p> <code>None</code> <code>capacity_mAh</code> <code>float | None</code> <p>(optional) Override the protocol sample capacity.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>json string representation of the protocol.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>def to_tomato_mpg2(\n    self,\n    save_path: Path | str | None = None,\n    tomato_output: Path = Path(\"C:/tomato_data/\"),\n    sample_name: str | None = None,\n    capacity_mAh: float | None = None,\n) -&gt; str:\n    \"\"\"Convert protocol to tomato 0.2.3 + MPG2 compatible JSON format.\n\n    Args:\n        save_path: (optional) File path of where to save the json file.\n        tomato_output: (optional) Where to save the data from tomato.\n        sample_name: (optional) Override the protocol sample name.\n        capacity_mAh: (optional) Override the protocol sample capacity.\n\n    Returns:\n        json string representation of the protocol.\n\n    \"\"\"\n    # Create and operate on a copy of the original object\n    protocol = self.model_copy()\n\n    # Allow overwriting name and capacity\n    if sample_name:\n        protocol.sample.name = sample_name\n    if capacity_mAh:\n        protocol.sample.capacity_mAh = capacity_mAh\n\n    # Make sure sample name is set\n    if not protocol.sample.name or protocol.sample.name == \"$NAME\":\n        msg = (\n            \"If using blank sample name or $NAME placeholder, \"\n            \"a sample name must be provided in this function.\"\n        )\n        raise ValueError(msg)\n\n    # Make sure capacity is set if using C-rate steps\n    protocol._validate_capacity_c_rates()\n\n    # Remove tags and convert to indices\n    protocol._tag_to_indices()\n    protocol._check_for_intersecting_loops()\n\n    # Create JSON structure\n    tomato_dict: dict = {\n        \"version\": \"0.1\",\n        \"sample\": {},\n        \"method\": [],\n        \"tomato\": {\n            \"unlock_when_done\": True,\n            \"verbosity\": \"DEBUG\",\n            \"output\": {\n                \"path\": str(tomato_output),\n                \"prefix\": protocol.sample.name,\n            },\n        },\n    }\n    # tomato -&gt; MPG2 does not support safety parameters, they are set in the instrument\n    tomato_dict[\"sample\"][\"name\"] = protocol.sample.name\n    tomato_dict[\"sample\"][\"capacity_mAh\"] = protocol.sample.capacity_mAh\n    for step in protocol.method:\n        tomato_step: dict = {}\n        tomato_step[\"device\"] = \"MPG2\"\n        tomato_step[\"technique\"] = step.step\n        if isinstance(step, (ConstantCurrent, ConstantVoltage, OpenCircuitVoltage)):\n            if protocol.record.time_s:\n                tomato_step[\"measure_every_dt\"] = protocol.record.time_s\n            if protocol.record.current_mA:\n                tomato_step[\"measure_every_dI\"] = protocol.record.current_mA\n            if protocol.record.voltage_V:\n                tomato_step[\"measure_every_dE\"] = protocol.record.voltage_V\n            tomato_step[\"I_range\"] = \"10 mA\"\n            tomato_step[\"E_range\"] = \"+-5.0 V\"\n\n        match step:\n            case OpenCircuitVoltage():\n                tomato_step[\"time\"] = step.until_time_s\n\n            case ConstantCurrent():\n                if step.rate_C:\n                    if step.rate_C &gt; 0:\n                        charging = True\n                        tomato_step[\"current\"] = str(step.rate_C) + \"C\"\n                    else:\n                        charging = False\n                        tomato_step[\"current\"] = str(abs(step.rate_C)) + \"D\"\n                elif step.current_mA:\n                    if step.current_mA &gt; 0:\n                        charging = True\n                        tomato_step[\"current\"] = step.current_mA / 1000\n                    else:\n                        charging = False\n                        tomato_step[\"current\"] = step.current_mA / 1000\n                else:\n                    msg = \"Must have a current or C-rate\"\n                    raise ValueError(msg)\n                if step.until_time_s:\n                    tomato_step[\"time\"] = step.until_time_s\n                if step.until_voltage_V:\n                    if charging:\n                        tomato_step[\"limit_voltage_max\"] = step.until_voltage_V\n                    else:\n                        tomato_step[\"limit_voltage_min\"] = step.until_voltage_V\n\n            case ConstantVoltage():\n                tomato_step[\"voltage\"] = step.voltage_V\n                if step.until_time_s:\n                    tomato_step[\"time\"] = step.until_time_s\n                if step.until_rate_C:\n                    if step.until_rate_C &gt; 0:\n                        tomato_step[\"limit_current_min\"] = str(step.until_rate_C) + \"C\"\n                    else:\n                        tomato_step[\"limit_current_max\"] = str(abs(step.until_rate_C)) + \"D\"\n\n            case Loop():\n                assert isinstance(step.loop_to, int)  # noqa: S101, from _tag_to_indices()\n                tomato_step[\"goto\"] = step.loop_to - 1  # 0-indexed in mpr\n                tomato_step[\"n_gotos\"] = step.cycle_count - 1  # gotos is one less than cycles\n\n            case _:\n                msg = f\"to_tomato_mpg2 does not support step type: {step.step}\"\n                raise TypeError(msg)\n\n        tomato_dict[\"method\"].append(tomato_step)\n\n    if save_path:\n        save_path = Path(save_path)\n        save_path.parent.mkdir(parents=True, exist_ok=True)\n        with save_path.open(\"w\", encoding=\"utf-8\") as f:\n            json.dump(tomato_dict, f, indent=4)\n    return json.dumps(tomato_dict, indent=4)\n</code></pre>"},{"location":"api/#aurora_unicycler.RecordParams","title":"<code>RecordParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Recording parameters.</p> <p>Attributes:</p> Name Type Description <code>current_mA</code> <code>float | None</code> <p>Current change in mA which triggers recording data.</p> <code>voltage_V</code> <code>float | None</code> <p>Voltage change in V which triggers recording data.</p> <code>time_s</code> <code>float</code> <p>Time in seconds between recording data.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class RecordParams(BaseModel):\n    \"\"\"Recording parameters.\n\n    Attributes:\n        current_mA: Current change in mA which triggers recording data.\n        voltage_V: Voltage change in V which triggers recording data.\n        time_s: Time in seconds between recording data.\n\n    \"\"\"\n\n    current_mA: float | None = None\n    voltage_V: float | None = None\n    time_s: float = Field(gt=0)\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"api/#aurora_unicycler.SafetyParams","title":"<code>SafetyParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Safety parameters, i.e. limits before cancelling the entire experiment.</p> <p>Attributes:</p> Name Type Description <code>max_voltage_V</code> <code>float | None</code> <p>Maximum voltage in V.</p> <code>min_voltage_V</code> <code>float | None</code> <p>Minimum voltage in V.</p> <code>max_current_mA</code> <code>float | None</code> <p>Maximum current in mA.</p> <code>min_current_mA</code> <code>float | None</code> <p>Minimum current in mA (can be negative).</p> <code>delay_s</code> <code>float | None</code> <p>How long in seconds limits must be exceeded before cancelling.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class SafetyParams(BaseModel):\n    \"\"\"Safety parameters, i.e. limits before cancelling the entire experiment.\n\n    Attributes:\n        max_voltage_V: Maximum voltage in V.\n        min_voltage_V: Minimum voltage in V.\n        max_current_mA: Maximum current in mA.\n        min_current_mA: Minimum current in mA (can be negative).\n        delay_s: How long in seconds limits must be exceeded before cancelling.\n\n    \"\"\"\n\n    max_voltage_V: float | None = None\n    min_voltage_V: float | None = None\n    max_current_mA: float | None = None\n    min_current_mA: float | None = None\n    max_capacity_mAh: float | None = Field(ge=0, default=None)\n    delay_s: float | None = Field(ge=0, default=None)\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"api/#aurora_unicycler.SampleParams","title":"<code>SampleParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Sample parameters.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Sample name.</p> <code>capacity_mAh</code> <code>float | None</code> <p>Sample capacity in mAh, used to calculate current from C-rates.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class SampleParams(BaseModel):\n    \"\"\"Sample parameters.\n\n    Attributes:\n        name: Sample name.\n        capacity_mAh: Sample capacity in mAh, used to calculate current from C-rates.\n\n    \"\"\"\n\n    name: str = Field(default=\"$NAME\")\n    capacity_mAh: float | None = Field(gt=0, default=None)\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"api/#aurora_unicycler.Step","title":"<code>Step</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all steps.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class Step(BaseModel):\n    \"\"\"Base class for all steps.\"\"\"\n\n    # optional id field\n    id: str | None = Field(default=None, description=\"Optional ID for the technique step\")\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"api/#aurora_unicycler.Tag","title":"<code>Tag</code>","text":"<p>               Bases: <code>Step</code></p> <p>Tag step.</p> <p>Used in combination with the Loop step, e.g. <pre><code>[\n    Tag(tag=\"formation\")\n    # Your cycling steps here\n    Loop(loop_to=\"formation\", cycle_count=3)\n]\n</code></pre></p> <p>This will loop over the cycling steps 3 times. Put the tag before the step you want to loop to.</p> <p>Can also be used for comments or organisation, but note that it will only be stored in unicycler, when sending to e.g. Biologic or Neware, loops/tags are converted to indices and the tag steps are removed.</p> <p>Attributes:</p> Name Type Description <code>tag</code> <code>str</code> <p>The tag name.</p> Source code in <code>aurora_unicycler/unicycler.py</code> <pre><code>class Tag(Step):\n    \"\"\"Tag step.\n\n    Used in combination with the Loop step, e.g.\n    ```\n    [\n        Tag(tag=\"formation\")\n        # Your cycling steps here\n        Loop(loop_to=\"formation\", cycle_count=3)\n    ]\n    ```\n\n    This will loop over the cycling steps 3 times. Put the tag before the step\n    you want to loop to.\n\n    Can also be used for comments or organisation, but note that it will only be\n    stored in unicycler, when sending to e.g. Biologic or Neware, loops/tags are\n    converted to indices and the tag steps are removed.\n\n    Attributes:\n        tag: The tag name.\n\n    \"\"\"\n\n    step: Literal[\"tag\"] = Field(default=\"tag\", frozen=True)\n    tag: str = Field(default=\"\")\n\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"battinfo/","title":"To BattINFO","text":"<p>With a <code>Protocol</code> object, use , use <code>to_battinfo_jsonld()</code></p> <pre><code>jsonld_string = my_protocol.to_battinfo_jsonld(\n    capacity_mAh=45,\n    include_context=True,\n    save_path=\"some/location/protocol.jsonld\",\n)\n</code></pre> <p>This returns a JSON-LD string, and optionally saves to a .jsonld file.</p> <p><code>include_context</code> adds a <code>@context</code> property to the root of the JSON.</p>"},{"location":"biologic/","title":"To Biologic mps","text":"<p>With a <code>Protocol</code> object, use <code>to_biologic_mps()</code></p> <pre><code>mps_string = my_protocol.to_biologic_mps(\n    sample_name=\"test-sample\",\n    capacity_mAh=45,\n    save_path=\"some/location/settings.mps\",\n)\n</code></pre> <p>This returns a Biologic MPS settings string, and optionally saves a .mps file.</p> <p>This has tested on MPG2 cyclers with EC-lab 11.52 and 11.61.</p> <p>Important!</p> <p>If you save the string to a file yourself, use <code>cp1252</code> encoding. <code>UTF-8</code> (default) will not save \u03bc (micro) symbols correctly. EC-lab can misinterpret this as m (milli) which could be dangerous!</p>"},{"location":"installation/","title":"Installation","text":"<p>The package is available on PyPI, install on Python &gt;3.10 with <pre><code>pip install aurora-unicycler\n</code></pre></p>"},{"location":"installation/#for-contributors","title":"For contributors","text":"<p>If you want to edit or contribute to the package, then clone the repo and install as editable with developer dependencies <pre><code>git clone https://github.com/empaeconversion/aurora-unicycler.git\ncd aurora-unicycler\npip install -e .[dev]\n</code></pre></p>"},{"location":"neware/","title":"To Neware xml","text":"<p>With a <code>Protocol</code> object, use <code>to_neware_xml()</code></p> <pre><code>xml_string = my_protocol.to_neware_xml(\n    sample_name=\"test-sample\",\n    capacity_mAh=45,\n    save_path=\"some/location/protocol.xml\",\n)\n</code></pre> <p>This returns an XML string, and optionally saves to a .xml file.</p> <p>This has been tested on BTS8.0.0.</p>"},{"location":"protocol/","title":"Creating a protocol","text":""},{"location":"protocol/#with-python-object","title":"With Python object","text":"<p>Writing the protocol using the Python objects gives the full power of type checking and validation in your developer environment, like VSCode. <pre><code>from aurora_unicycler import (\n    ConstantCurrent,\n    ConstantVoltage,\n    Loop,\n    Protocol,\n    RecordParams,\n    SafetyParams,\n    Tag,\n)\n\nmy_protocol = Protocol(\n    record = RecordParams(\n        time_s=10,\n        voltage_V=0.1,\n    ),\n    safety = SafetyParams(\n        max_voltage_V=5,\n        min_voltage_V=0,\n        max_current_mA=10,\n        min_current_mA=-10,\n    ),\n    method = [\n        Tag(\n            tag=\"my_tag\",\n        ),\n        ConstantCurrent(\n            rate_C=0.5,\n            until_voltage_V=4.2,\n            until_time_s=3*60*60,\n        ),\n        ConstantVoltage(\n            voltage_V=4.2,\n            until_rate_C=0.05,\n            until_time_s=60*60,\n        ),\n        ConstantCurrent(\n            rate_C=-0.5,\n            until_voltage_V=3.5,\n            until_time_s=3*60*60,\n        ),\n        Loop(\n            loop_to=\"my_tag\",\n            cycle_count=100,\n        )\n    ]\n)\n</code></pre></p>"},{"location":"protocol/#with-dictionary","title":"With dictionary","text":"<p>You can also create a protocol from a python dictionary - you will not get type checking in an IDE, but it will still validate at runtime. <pre><code>from aurora_unicycler import Protocol\n\nmy_protocol = Protocol.from_dict({\n    \"record\": {\"time_s\": 10, \"voltage_V\": 0.1},\n    \"safety\": {\"max_voltage_V\": 5},\n    \"method\": [\n        {\"step\": \"open_circuit_voltage\", \"until_time_s\": 1},\n        {\"step\": \"tag\", \"tag\": \"tag1\"},\n        {\"step\": \"constant_current\", \"rate_C\": 0.5, \"until_voltage_V\": 4.2},\n        {\"step\": \"constant_voltage\", \"voltage_V\": 4.2, \"until_rate_C\": 0.05},\n        {\"step\": \"constant_current\", \"rate_C\": -0.5, \"until_voltage_V\": 3.0},\n        {\"step\": \"loop\", \"loop_to\": \"tag1\", \"cycle_count\": 100},\n    ],\n})\n</code></pre></p>"},{"location":"protocol/#with-json","title":"With JSON","text":"<p>It is also possible to load a protocol from a JSON file. <pre><code>from aurora_unicycler import Protocol\n\nmy_protocol = Protocol.from_json(\"path/to/file.json\")\n</code></pre></p>"},{"location":"pybamm/","title":"To PyBaMM","text":"<p>With a <code>Protocol</code> object, use , use <code>to_pybamm_experiment()</code></p> <pre><code>pybamm_list = my_protocol.to_pybamm_experiment()\n</code></pre> <p>This creates a list of strings which can be used in PyBaMM.</p> <p>Note: if you serialise this as a text file, it can be very large. A cycle in PyBaMM is not stored with e.g. 'Cycle 1000 times' - the cycle itself is repeated 1000 times. It is better to keep this as a Python object where possible.</p>"}]}